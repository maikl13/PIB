// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'requests_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$RequestState<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() myRequestsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myRequestsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myRequestsError,
    required TResult Function() offersLoading,
    required TResult Function(List<OfferModel> offers) offersSuccess,
    required TResult Function(NetworkExceptions networkExceptions) offersError,
    required TResult Function() myAvailableJobsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myAvailableJobsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myAvailableJobsError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? myRequestsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult? Function()? offersLoading,
    TResult? Function(List<OfferModel> offers)? offersSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? offersError,
    TResult? Function()? myAvailableJobsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)?
        myAvailableJobsError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? myRequestsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult Function()? offersLoading,
    TResult Function(List<OfferModel> offers)? offersSuccess,
    TResult Function(NetworkExceptions networkExceptions)? offersError,
    TResult Function()? myAvailableJobsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myAvailableJobsError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(MyRequestsLoading<T> value) myRequestsLoading,
    required TResult Function(MyRequestsSuccess<T> value) myRequestsSuccess,
    required TResult Function(MyRequestsError<T> value) myRequestsError,
    required TResult Function(OffersLoading<T> value) offersLoading,
    required TResult Function(OffersSuccess<T> value) offersSuccess,
    required TResult Function(OffersError<T> value) offersError,
    required TResult Function(MyAvailableJobsLoading<T> value)
        myAvailableJobsLoading,
    required TResult Function(MyAvailableJobsSuccess<T> value)
        myAvailableJobsSuccess,
    required TResult Function(MyAvailableJobsError<T> value)
        myAvailableJobsError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult? Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult? Function(MyRequestsError<T> value)? myRequestsError,
    TResult? Function(OffersLoading<T> value)? offersLoading,
    TResult? Function(OffersSuccess<T> value)? offersSuccess,
    TResult? Function(OffersError<T> value)? offersError,
    TResult? Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult? Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult? Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult Function(MyRequestsError<T> value)? myRequestsError,
    TResult Function(OffersLoading<T> value)? offersLoading,
    TResult Function(OffersSuccess<T> value)? offersSuccess,
    TResult Function(OffersError<T> value)? offersError,
    TResult Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RequestStateCopyWith<T, $Res> {
  factory $RequestStateCopyWith(
          RequestState<T> value, $Res Function(RequestState<T>) then) =
      _$RequestStateCopyWithImpl<T, $Res, RequestState<T>>;
}

/// @nodoc
class _$RequestStateCopyWithImpl<T, $Res, $Val extends RequestState<T>>
    implements $RequestStateCopyWith<T, $Res> {
  _$RequestStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$IdleCopyWith<T, $Res> {
  factory _$$IdleCopyWith(_$Idle<T> value, $Res Function(_$Idle<T>) then) =
      __$$IdleCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$IdleCopyWithImpl<T, $Res>
    extends _$RequestStateCopyWithImpl<T, $Res, _$Idle<T>>
    implements _$$IdleCopyWith<T, $Res> {
  __$$IdleCopyWithImpl(_$Idle<T> _value, $Res Function(_$Idle<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Idle<T> implements Idle<T> {
  const _$Idle();

  @override
  String toString() {
    return 'RequestState<$T>.idle()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Idle<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() myRequestsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myRequestsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myRequestsError,
    required TResult Function() offersLoading,
    required TResult Function(List<OfferModel> offers) offersSuccess,
    required TResult Function(NetworkExceptions networkExceptions) offersError,
    required TResult Function() myAvailableJobsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myAvailableJobsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myAvailableJobsError,
  }) {
    return idle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? myRequestsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult? Function()? offersLoading,
    TResult? Function(List<OfferModel> offers)? offersSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? offersError,
    TResult? Function()? myAvailableJobsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)?
        myAvailableJobsError,
  }) {
    return idle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? myRequestsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult Function()? offersLoading,
    TResult Function(List<OfferModel> offers)? offersSuccess,
    TResult Function(NetworkExceptions networkExceptions)? offersError,
    TResult Function()? myAvailableJobsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(MyRequestsLoading<T> value) myRequestsLoading,
    required TResult Function(MyRequestsSuccess<T> value) myRequestsSuccess,
    required TResult Function(MyRequestsError<T> value) myRequestsError,
    required TResult Function(OffersLoading<T> value) offersLoading,
    required TResult Function(OffersSuccess<T> value) offersSuccess,
    required TResult Function(OffersError<T> value) offersError,
    required TResult Function(MyAvailableJobsLoading<T> value)
        myAvailableJobsLoading,
    required TResult Function(MyAvailableJobsSuccess<T> value)
        myAvailableJobsSuccess,
    required TResult Function(MyAvailableJobsError<T> value)
        myAvailableJobsError,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult? Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult? Function(MyRequestsError<T> value)? myRequestsError,
    TResult? Function(OffersLoading<T> value)? offersLoading,
    TResult? Function(OffersSuccess<T> value)? offersSuccess,
    TResult? Function(OffersError<T> value)? offersError,
    TResult? Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult? Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult? Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult Function(MyRequestsError<T> value)? myRequestsError,
    TResult Function(OffersLoading<T> value)? offersLoading,
    TResult Function(OffersSuccess<T> value)? offersSuccess,
    TResult Function(OffersError<T> value)? offersError,
    TResult Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class Idle<T> implements RequestState<T> {
  const factory Idle() = _$Idle<T>;
}

/// @nodoc
abstract class _$$MyRequestsLoadingCopyWith<T, $Res> {
  factory _$$MyRequestsLoadingCopyWith(_$MyRequestsLoading<T> value,
          $Res Function(_$MyRequestsLoading<T>) then) =
      __$$MyRequestsLoadingCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$MyRequestsLoadingCopyWithImpl<T, $Res>
    extends _$RequestStateCopyWithImpl<T, $Res, _$MyRequestsLoading<T>>
    implements _$$MyRequestsLoadingCopyWith<T, $Res> {
  __$$MyRequestsLoadingCopyWithImpl(_$MyRequestsLoading<T> _value,
      $Res Function(_$MyRequestsLoading<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MyRequestsLoading<T> implements MyRequestsLoading<T> {
  const _$MyRequestsLoading();

  @override
  String toString() {
    return 'RequestState<$T>.myRequestsLoading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MyRequestsLoading<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() myRequestsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myRequestsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myRequestsError,
    required TResult Function() offersLoading,
    required TResult Function(List<OfferModel> offers) offersSuccess,
    required TResult Function(NetworkExceptions networkExceptions) offersError,
    required TResult Function() myAvailableJobsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myAvailableJobsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myAvailableJobsError,
  }) {
    return myRequestsLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? myRequestsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult? Function()? offersLoading,
    TResult? Function(List<OfferModel> offers)? offersSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? offersError,
    TResult? Function()? myAvailableJobsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)?
        myAvailableJobsError,
  }) {
    return myRequestsLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? myRequestsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult Function()? offersLoading,
    TResult Function(List<OfferModel> offers)? offersSuccess,
    TResult Function(NetworkExceptions networkExceptions)? offersError,
    TResult Function()? myAvailableJobsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (myRequestsLoading != null) {
      return myRequestsLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(MyRequestsLoading<T> value) myRequestsLoading,
    required TResult Function(MyRequestsSuccess<T> value) myRequestsSuccess,
    required TResult Function(MyRequestsError<T> value) myRequestsError,
    required TResult Function(OffersLoading<T> value) offersLoading,
    required TResult Function(OffersSuccess<T> value) offersSuccess,
    required TResult Function(OffersError<T> value) offersError,
    required TResult Function(MyAvailableJobsLoading<T> value)
        myAvailableJobsLoading,
    required TResult Function(MyAvailableJobsSuccess<T> value)
        myAvailableJobsSuccess,
    required TResult Function(MyAvailableJobsError<T> value)
        myAvailableJobsError,
  }) {
    return myRequestsLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult? Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult? Function(MyRequestsError<T> value)? myRequestsError,
    TResult? Function(OffersLoading<T> value)? offersLoading,
    TResult? Function(OffersSuccess<T> value)? offersSuccess,
    TResult? Function(OffersError<T> value)? offersError,
    TResult? Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult? Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult? Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
  }) {
    return myRequestsLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult Function(MyRequestsError<T> value)? myRequestsError,
    TResult Function(OffersLoading<T> value)? offersLoading,
    TResult Function(OffersSuccess<T> value)? offersSuccess,
    TResult Function(OffersError<T> value)? offersError,
    TResult Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (myRequestsLoading != null) {
      return myRequestsLoading(this);
    }
    return orElse();
  }
}

abstract class MyRequestsLoading<T> implements RequestState<T> {
  const factory MyRequestsLoading() = _$MyRequestsLoading<T>;
}

/// @nodoc
abstract class _$$MyRequestsSuccessCopyWith<T, $Res> {
  factory _$$MyRequestsSuccessCopyWith(_$MyRequestsSuccess<T> value,
          $Res Function(_$MyRequestsSuccess<T>) then) =
      __$$MyRequestsSuccessCopyWithImpl<T, $Res>;
  @useResult
  $Res call({List<MyRequestModel> myRequests});
}

/// @nodoc
class __$$MyRequestsSuccessCopyWithImpl<T, $Res>
    extends _$RequestStateCopyWithImpl<T, $Res, _$MyRequestsSuccess<T>>
    implements _$$MyRequestsSuccessCopyWith<T, $Res> {
  __$$MyRequestsSuccessCopyWithImpl(_$MyRequestsSuccess<T> _value,
      $Res Function(_$MyRequestsSuccess<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? myRequests = null,
  }) {
    return _then(_$MyRequestsSuccess<T>(
      null == myRequests
          ? _value._myRequests
          : myRequests // ignore: cast_nullable_to_non_nullable
              as List<MyRequestModel>,
    ));
  }
}

/// @nodoc

class _$MyRequestsSuccess<T> implements MyRequestsSuccess<T> {
  const _$MyRequestsSuccess(final List<MyRequestModel> myRequests)
      : _myRequests = myRequests;

  final List<MyRequestModel> _myRequests;
  @override
  List<MyRequestModel> get myRequests {
    if (_myRequests is EqualUnmodifiableListView) return _myRequests;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_myRequests);
  }

  @override
  String toString() {
    return 'RequestState<$T>.myRequestsSuccess(myRequests: $myRequests)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyRequestsSuccess<T> &&
            const DeepCollectionEquality()
                .equals(other._myRequests, _myRequests));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_myRequests));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyRequestsSuccessCopyWith<T, _$MyRequestsSuccess<T>> get copyWith =>
      __$$MyRequestsSuccessCopyWithImpl<T, _$MyRequestsSuccess<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() myRequestsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myRequestsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myRequestsError,
    required TResult Function() offersLoading,
    required TResult Function(List<OfferModel> offers) offersSuccess,
    required TResult Function(NetworkExceptions networkExceptions) offersError,
    required TResult Function() myAvailableJobsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myAvailableJobsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myAvailableJobsError,
  }) {
    return myRequestsSuccess(myRequests);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? myRequestsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult? Function()? offersLoading,
    TResult? Function(List<OfferModel> offers)? offersSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? offersError,
    TResult? Function()? myAvailableJobsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)?
        myAvailableJobsError,
  }) {
    return myRequestsSuccess?.call(myRequests);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? myRequestsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult Function()? offersLoading,
    TResult Function(List<OfferModel> offers)? offersSuccess,
    TResult Function(NetworkExceptions networkExceptions)? offersError,
    TResult Function()? myAvailableJobsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (myRequestsSuccess != null) {
      return myRequestsSuccess(myRequests);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(MyRequestsLoading<T> value) myRequestsLoading,
    required TResult Function(MyRequestsSuccess<T> value) myRequestsSuccess,
    required TResult Function(MyRequestsError<T> value) myRequestsError,
    required TResult Function(OffersLoading<T> value) offersLoading,
    required TResult Function(OffersSuccess<T> value) offersSuccess,
    required TResult Function(OffersError<T> value) offersError,
    required TResult Function(MyAvailableJobsLoading<T> value)
        myAvailableJobsLoading,
    required TResult Function(MyAvailableJobsSuccess<T> value)
        myAvailableJobsSuccess,
    required TResult Function(MyAvailableJobsError<T> value)
        myAvailableJobsError,
  }) {
    return myRequestsSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult? Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult? Function(MyRequestsError<T> value)? myRequestsError,
    TResult? Function(OffersLoading<T> value)? offersLoading,
    TResult? Function(OffersSuccess<T> value)? offersSuccess,
    TResult? Function(OffersError<T> value)? offersError,
    TResult? Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult? Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult? Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
  }) {
    return myRequestsSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult Function(MyRequestsError<T> value)? myRequestsError,
    TResult Function(OffersLoading<T> value)? offersLoading,
    TResult Function(OffersSuccess<T> value)? offersSuccess,
    TResult Function(OffersError<T> value)? offersError,
    TResult Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (myRequestsSuccess != null) {
      return myRequestsSuccess(this);
    }
    return orElse();
  }
}

abstract class MyRequestsSuccess<T> implements RequestState<T> {
  const factory MyRequestsSuccess(final List<MyRequestModel> myRequests) =
      _$MyRequestsSuccess<T>;

  List<MyRequestModel> get myRequests;
  @JsonKey(ignore: true)
  _$$MyRequestsSuccessCopyWith<T, _$MyRequestsSuccess<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MyRequestsErrorCopyWith<T, $Res> {
  factory _$$MyRequestsErrorCopyWith(_$MyRequestsError<T> value,
          $Res Function(_$MyRequestsError<T>) then) =
      __$$MyRequestsErrorCopyWithImpl<T, $Res>;
  @useResult
  $Res call({NetworkExceptions networkExceptions});

  $NetworkExceptionsCopyWith<$Res> get networkExceptions;
}

/// @nodoc
class __$$MyRequestsErrorCopyWithImpl<T, $Res>
    extends _$RequestStateCopyWithImpl<T, $Res, _$MyRequestsError<T>>
    implements _$$MyRequestsErrorCopyWith<T, $Res> {
  __$$MyRequestsErrorCopyWithImpl(
      _$MyRequestsError<T> _value, $Res Function(_$MyRequestsError<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? networkExceptions = null,
  }) {
    return _then(_$MyRequestsError<T>(
      null == networkExceptions
          ? _value.networkExceptions
          : networkExceptions // ignore: cast_nullable_to_non_nullable
              as NetworkExceptions,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NetworkExceptionsCopyWith<$Res> get networkExceptions {
    return $NetworkExceptionsCopyWith<$Res>(_value.networkExceptions, (value) {
      return _then(_value.copyWith(networkExceptions: value));
    });
  }
}

/// @nodoc

class _$MyRequestsError<T> implements MyRequestsError<T> {
  const _$MyRequestsError(this.networkExceptions);

  @override
  final NetworkExceptions networkExceptions;

  @override
  String toString() {
    return 'RequestState<$T>.myRequestsError(networkExceptions: $networkExceptions)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyRequestsError<T> &&
            (identical(other.networkExceptions, networkExceptions) ||
                other.networkExceptions == networkExceptions));
  }

  @override
  int get hashCode => Object.hash(runtimeType, networkExceptions);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyRequestsErrorCopyWith<T, _$MyRequestsError<T>> get copyWith =>
      __$$MyRequestsErrorCopyWithImpl<T, _$MyRequestsError<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() myRequestsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myRequestsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myRequestsError,
    required TResult Function() offersLoading,
    required TResult Function(List<OfferModel> offers) offersSuccess,
    required TResult Function(NetworkExceptions networkExceptions) offersError,
    required TResult Function() myAvailableJobsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myAvailableJobsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myAvailableJobsError,
  }) {
    return myRequestsError(networkExceptions);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? myRequestsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult? Function()? offersLoading,
    TResult? Function(List<OfferModel> offers)? offersSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? offersError,
    TResult? Function()? myAvailableJobsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)?
        myAvailableJobsError,
  }) {
    return myRequestsError?.call(networkExceptions);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? myRequestsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult Function()? offersLoading,
    TResult Function(List<OfferModel> offers)? offersSuccess,
    TResult Function(NetworkExceptions networkExceptions)? offersError,
    TResult Function()? myAvailableJobsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (myRequestsError != null) {
      return myRequestsError(networkExceptions);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(MyRequestsLoading<T> value) myRequestsLoading,
    required TResult Function(MyRequestsSuccess<T> value) myRequestsSuccess,
    required TResult Function(MyRequestsError<T> value) myRequestsError,
    required TResult Function(OffersLoading<T> value) offersLoading,
    required TResult Function(OffersSuccess<T> value) offersSuccess,
    required TResult Function(OffersError<T> value) offersError,
    required TResult Function(MyAvailableJobsLoading<T> value)
        myAvailableJobsLoading,
    required TResult Function(MyAvailableJobsSuccess<T> value)
        myAvailableJobsSuccess,
    required TResult Function(MyAvailableJobsError<T> value)
        myAvailableJobsError,
  }) {
    return myRequestsError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult? Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult? Function(MyRequestsError<T> value)? myRequestsError,
    TResult? Function(OffersLoading<T> value)? offersLoading,
    TResult? Function(OffersSuccess<T> value)? offersSuccess,
    TResult? Function(OffersError<T> value)? offersError,
    TResult? Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult? Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult? Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
  }) {
    return myRequestsError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult Function(MyRequestsError<T> value)? myRequestsError,
    TResult Function(OffersLoading<T> value)? offersLoading,
    TResult Function(OffersSuccess<T> value)? offersSuccess,
    TResult Function(OffersError<T> value)? offersError,
    TResult Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (myRequestsError != null) {
      return myRequestsError(this);
    }
    return orElse();
  }
}

abstract class MyRequestsError<T> implements RequestState<T> {
  const factory MyRequestsError(final NetworkExceptions networkExceptions) =
      _$MyRequestsError<T>;

  NetworkExceptions get networkExceptions;
  @JsonKey(ignore: true)
  _$$MyRequestsErrorCopyWith<T, _$MyRequestsError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OffersLoadingCopyWith<T, $Res> {
  factory _$$OffersLoadingCopyWith(
          _$OffersLoading<T> value, $Res Function(_$OffersLoading<T>) then) =
      __$$OffersLoadingCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$OffersLoadingCopyWithImpl<T, $Res>
    extends _$RequestStateCopyWithImpl<T, $Res, _$OffersLoading<T>>
    implements _$$OffersLoadingCopyWith<T, $Res> {
  __$$OffersLoadingCopyWithImpl(
      _$OffersLoading<T> _value, $Res Function(_$OffersLoading<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OffersLoading<T> implements OffersLoading<T> {
  const _$OffersLoading();

  @override
  String toString() {
    return 'RequestState<$T>.offersLoading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OffersLoading<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() myRequestsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myRequestsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myRequestsError,
    required TResult Function() offersLoading,
    required TResult Function(List<OfferModel> offers) offersSuccess,
    required TResult Function(NetworkExceptions networkExceptions) offersError,
    required TResult Function() myAvailableJobsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myAvailableJobsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myAvailableJobsError,
  }) {
    return offersLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? myRequestsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult? Function()? offersLoading,
    TResult? Function(List<OfferModel> offers)? offersSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? offersError,
    TResult? Function()? myAvailableJobsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)?
        myAvailableJobsError,
  }) {
    return offersLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? myRequestsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult Function()? offersLoading,
    TResult Function(List<OfferModel> offers)? offersSuccess,
    TResult Function(NetworkExceptions networkExceptions)? offersError,
    TResult Function()? myAvailableJobsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (offersLoading != null) {
      return offersLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(MyRequestsLoading<T> value) myRequestsLoading,
    required TResult Function(MyRequestsSuccess<T> value) myRequestsSuccess,
    required TResult Function(MyRequestsError<T> value) myRequestsError,
    required TResult Function(OffersLoading<T> value) offersLoading,
    required TResult Function(OffersSuccess<T> value) offersSuccess,
    required TResult Function(OffersError<T> value) offersError,
    required TResult Function(MyAvailableJobsLoading<T> value)
        myAvailableJobsLoading,
    required TResult Function(MyAvailableJobsSuccess<T> value)
        myAvailableJobsSuccess,
    required TResult Function(MyAvailableJobsError<T> value)
        myAvailableJobsError,
  }) {
    return offersLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult? Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult? Function(MyRequestsError<T> value)? myRequestsError,
    TResult? Function(OffersLoading<T> value)? offersLoading,
    TResult? Function(OffersSuccess<T> value)? offersSuccess,
    TResult? Function(OffersError<T> value)? offersError,
    TResult? Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult? Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult? Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
  }) {
    return offersLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult Function(MyRequestsError<T> value)? myRequestsError,
    TResult Function(OffersLoading<T> value)? offersLoading,
    TResult Function(OffersSuccess<T> value)? offersSuccess,
    TResult Function(OffersError<T> value)? offersError,
    TResult Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (offersLoading != null) {
      return offersLoading(this);
    }
    return orElse();
  }
}

abstract class OffersLoading<T> implements RequestState<T> {
  const factory OffersLoading() = _$OffersLoading<T>;
}

/// @nodoc
abstract class _$$OffersSuccessCopyWith<T, $Res> {
  factory _$$OffersSuccessCopyWith(
          _$OffersSuccess<T> value, $Res Function(_$OffersSuccess<T>) then) =
      __$$OffersSuccessCopyWithImpl<T, $Res>;
  @useResult
  $Res call({List<OfferModel> offers});
}

/// @nodoc
class __$$OffersSuccessCopyWithImpl<T, $Res>
    extends _$RequestStateCopyWithImpl<T, $Res, _$OffersSuccess<T>>
    implements _$$OffersSuccessCopyWith<T, $Res> {
  __$$OffersSuccessCopyWithImpl(
      _$OffersSuccess<T> _value, $Res Function(_$OffersSuccess<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offers = null,
  }) {
    return _then(_$OffersSuccess<T>(
      null == offers
          ? _value._offers
          : offers // ignore: cast_nullable_to_non_nullable
              as List<OfferModel>,
    ));
  }
}

/// @nodoc

class _$OffersSuccess<T> implements OffersSuccess<T> {
  const _$OffersSuccess(final List<OfferModel> offers) : _offers = offers;

  final List<OfferModel> _offers;
  @override
  List<OfferModel> get offers {
    if (_offers is EqualUnmodifiableListView) return _offers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_offers);
  }

  @override
  String toString() {
    return 'RequestState<$T>.offersSuccess(offers: $offers)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OffersSuccess<T> &&
            const DeepCollectionEquality().equals(other._offers, _offers));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_offers));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OffersSuccessCopyWith<T, _$OffersSuccess<T>> get copyWith =>
      __$$OffersSuccessCopyWithImpl<T, _$OffersSuccess<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() myRequestsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myRequestsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myRequestsError,
    required TResult Function() offersLoading,
    required TResult Function(List<OfferModel> offers) offersSuccess,
    required TResult Function(NetworkExceptions networkExceptions) offersError,
    required TResult Function() myAvailableJobsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myAvailableJobsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myAvailableJobsError,
  }) {
    return offersSuccess(offers);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? myRequestsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult? Function()? offersLoading,
    TResult? Function(List<OfferModel> offers)? offersSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? offersError,
    TResult? Function()? myAvailableJobsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)?
        myAvailableJobsError,
  }) {
    return offersSuccess?.call(offers);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? myRequestsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult Function()? offersLoading,
    TResult Function(List<OfferModel> offers)? offersSuccess,
    TResult Function(NetworkExceptions networkExceptions)? offersError,
    TResult Function()? myAvailableJobsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (offersSuccess != null) {
      return offersSuccess(offers);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(MyRequestsLoading<T> value) myRequestsLoading,
    required TResult Function(MyRequestsSuccess<T> value) myRequestsSuccess,
    required TResult Function(MyRequestsError<T> value) myRequestsError,
    required TResult Function(OffersLoading<T> value) offersLoading,
    required TResult Function(OffersSuccess<T> value) offersSuccess,
    required TResult Function(OffersError<T> value) offersError,
    required TResult Function(MyAvailableJobsLoading<T> value)
        myAvailableJobsLoading,
    required TResult Function(MyAvailableJobsSuccess<T> value)
        myAvailableJobsSuccess,
    required TResult Function(MyAvailableJobsError<T> value)
        myAvailableJobsError,
  }) {
    return offersSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult? Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult? Function(MyRequestsError<T> value)? myRequestsError,
    TResult? Function(OffersLoading<T> value)? offersLoading,
    TResult? Function(OffersSuccess<T> value)? offersSuccess,
    TResult? Function(OffersError<T> value)? offersError,
    TResult? Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult? Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult? Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
  }) {
    return offersSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult Function(MyRequestsError<T> value)? myRequestsError,
    TResult Function(OffersLoading<T> value)? offersLoading,
    TResult Function(OffersSuccess<T> value)? offersSuccess,
    TResult Function(OffersError<T> value)? offersError,
    TResult Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (offersSuccess != null) {
      return offersSuccess(this);
    }
    return orElse();
  }
}

abstract class OffersSuccess<T> implements RequestState<T> {
  const factory OffersSuccess(final List<OfferModel> offers) =
      _$OffersSuccess<T>;

  List<OfferModel> get offers;
  @JsonKey(ignore: true)
  _$$OffersSuccessCopyWith<T, _$OffersSuccess<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OffersErrorCopyWith<T, $Res> {
  factory _$$OffersErrorCopyWith(
          _$OffersError<T> value, $Res Function(_$OffersError<T>) then) =
      __$$OffersErrorCopyWithImpl<T, $Res>;
  @useResult
  $Res call({NetworkExceptions networkExceptions});

  $NetworkExceptionsCopyWith<$Res> get networkExceptions;
}

/// @nodoc
class __$$OffersErrorCopyWithImpl<T, $Res>
    extends _$RequestStateCopyWithImpl<T, $Res, _$OffersError<T>>
    implements _$$OffersErrorCopyWith<T, $Res> {
  __$$OffersErrorCopyWithImpl(
      _$OffersError<T> _value, $Res Function(_$OffersError<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? networkExceptions = null,
  }) {
    return _then(_$OffersError<T>(
      null == networkExceptions
          ? _value.networkExceptions
          : networkExceptions // ignore: cast_nullable_to_non_nullable
              as NetworkExceptions,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NetworkExceptionsCopyWith<$Res> get networkExceptions {
    return $NetworkExceptionsCopyWith<$Res>(_value.networkExceptions, (value) {
      return _then(_value.copyWith(networkExceptions: value));
    });
  }
}

/// @nodoc

class _$OffersError<T> implements OffersError<T> {
  const _$OffersError(this.networkExceptions);

  @override
  final NetworkExceptions networkExceptions;

  @override
  String toString() {
    return 'RequestState<$T>.offersError(networkExceptions: $networkExceptions)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OffersError<T> &&
            (identical(other.networkExceptions, networkExceptions) ||
                other.networkExceptions == networkExceptions));
  }

  @override
  int get hashCode => Object.hash(runtimeType, networkExceptions);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OffersErrorCopyWith<T, _$OffersError<T>> get copyWith =>
      __$$OffersErrorCopyWithImpl<T, _$OffersError<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() myRequestsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myRequestsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myRequestsError,
    required TResult Function() offersLoading,
    required TResult Function(List<OfferModel> offers) offersSuccess,
    required TResult Function(NetworkExceptions networkExceptions) offersError,
    required TResult Function() myAvailableJobsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myAvailableJobsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myAvailableJobsError,
  }) {
    return offersError(networkExceptions);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? myRequestsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult? Function()? offersLoading,
    TResult? Function(List<OfferModel> offers)? offersSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? offersError,
    TResult? Function()? myAvailableJobsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)?
        myAvailableJobsError,
  }) {
    return offersError?.call(networkExceptions);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? myRequestsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult Function()? offersLoading,
    TResult Function(List<OfferModel> offers)? offersSuccess,
    TResult Function(NetworkExceptions networkExceptions)? offersError,
    TResult Function()? myAvailableJobsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (offersError != null) {
      return offersError(networkExceptions);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(MyRequestsLoading<T> value) myRequestsLoading,
    required TResult Function(MyRequestsSuccess<T> value) myRequestsSuccess,
    required TResult Function(MyRequestsError<T> value) myRequestsError,
    required TResult Function(OffersLoading<T> value) offersLoading,
    required TResult Function(OffersSuccess<T> value) offersSuccess,
    required TResult Function(OffersError<T> value) offersError,
    required TResult Function(MyAvailableJobsLoading<T> value)
        myAvailableJobsLoading,
    required TResult Function(MyAvailableJobsSuccess<T> value)
        myAvailableJobsSuccess,
    required TResult Function(MyAvailableJobsError<T> value)
        myAvailableJobsError,
  }) {
    return offersError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult? Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult? Function(MyRequestsError<T> value)? myRequestsError,
    TResult? Function(OffersLoading<T> value)? offersLoading,
    TResult? Function(OffersSuccess<T> value)? offersSuccess,
    TResult? Function(OffersError<T> value)? offersError,
    TResult? Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult? Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult? Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
  }) {
    return offersError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult Function(MyRequestsError<T> value)? myRequestsError,
    TResult Function(OffersLoading<T> value)? offersLoading,
    TResult Function(OffersSuccess<T> value)? offersSuccess,
    TResult Function(OffersError<T> value)? offersError,
    TResult Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (offersError != null) {
      return offersError(this);
    }
    return orElse();
  }
}

abstract class OffersError<T> implements RequestState<T> {
  const factory OffersError(final NetworkExceptions networkExceptions) =
      _$OffersError<T>;

  NetworkExceptions get networkExceptions;
  @JsonKey(ignore: true)
  _$$OffersErrorCopyWith<T, _$OffersError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MyAvailableJobsLoadingCopyWith<T, $Res> {
  factory _$$MyAvailableJobsLoadingCopyWith(_$MyAvailableJobsLoading<T> value,
          $Res Function(_$MyAvailableJobsLoading<T>) then) =
      __$$MyAvailableJobsLoadingCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$MyAvailableJobsLoadingCopyWithImpl<T, $Res>
    extends _$RequestStateCopyWithImpl<T, $Res, _$MyAvailableJobsLoading<T>>
    implements _$$MyAvailableJobsLoadingCopyWith<T, $Res> {
  __$$MyAvailableJobsLoadingCopyWithImpl(_$MyAvailableJobsLoading<T> _value,
      $Res Function(_$MyAvailableJobsLoading<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MyAvailableJobsLoading<T> implements MyAvailableJobsLoading<T> {
  const _$MyAvailableJobsLoading();

  @override
  String toString() {
    return 'RequestState<$T>.myAvailableJobsLoading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyAvailableJobsLoading<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() myRequestsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myRequestsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myRequestsError,
    required TResult Function() offersLoading,
    required TResult Function(List<OfferModel> offers) offersSuccess,
    required TResult Function(NetworkExceptions networkExceptions) offersError,
    required TResult Function() myAvailableJobsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myAvailableJobsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myAvailableJobsError,
  }) {
    return myAvailableJobsLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? myRequestsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult? Function()? offersLoading,
    TResult? Function(List<OfferModel> offers)? offersSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? offersError,
    TResult? Function()? myAvailableJobsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)?
        myAvailableJobsError,
  }) {
    return myAvailableJobsLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? myRequestsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult Function()? offersLoading,
    TResult Function(List<OfferModel> offers)? offersSuccess,
    TResult Function(NetworkExceptions networkExceptions)? offersError,
    TResult Function()? myAvailableJobsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (myAvailableJobsLoading != null) {
      return myAvailableJobsLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(MyRequestsLoading<T> value) myRequestsLoading,
    required TResult Function(MyRequestsSuccess<T> value) myRequestsSuccess,
    required TResult Function(MyRequestsError<T> value) myRequestsError,
    required TResult Function(OffersLoading<T> value) offersLoading,
    required TResult Function(OffersSuccess<T> value) offersSuccess,
    required TResult Function(OffersError<T> value) offersError,
    required TResult Function(MyAvailableJobsLoading<T> value)
        myAvailableJobsLoading,
    required TResult Function(MyAvailableJobsSuccess<T> value)
        myAvailableJobsSuccess,
    required TResult Function(MyAvailableJobsError<T> value)
        myAvailableJobsError,
  }) {
    return myAvailableJobsLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult? Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult? Function(MyRequestsError<T> value)? myRequestsError,
    TResult? Function(OffersLoading<T> value)? offersLoading,
    TResult? Function(OffersSuccess<T> value)? offersSuccess,
    TResult? Function(OffersError<T> value)? offersError,
    TResult? Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult? Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult? Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
  }) {
    return myAvailableJobsLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult Function(MyRequestsError<T> value)? myRequestsError,
    TResult Function(OffersLoading<T> value)? offersLoading,
    TResult Function(OffersSuccess<T> value)? offersSuccess,
    TResult Function(OffersError<T> value)? offersError,
    TResult Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (myAvailableJobsLoading != null) {
      return myAvailableJobsLoading(this);
    }
    return orElse();
  }
}

abstract class MyAvailableJobsLoading<T> implements RequestState<T> {
  const factory MyAvailableJobsLoading() = _$MyAvailableJobsLoading<T>;
}

/// @nodoc
abstract class _$$MyAvailableJobsSuccessCopyWith<T, $Res> {
  factory _$$MyAvailableJobsSuccessCopyWith(_$MyAvailableJobsSuccess<T> value,
          $Res Function(_$MyAvailableJobsSuccess<T>) then) =
      __$$MyAvailableJobsSuccessCopyWithImpl<T, $Res>;
  @useResult
  $Res call({List<MyRequestModel> myRequests});
}

/// @nodoc
class __$$MyAvailableJobsSuccessCopyWithImpl<T, $Res>
    extends _$RequestStateCopyWithImpl<T, $Res, _$MyAvailableJobsSuccess<T>>
    implements _$$MyAvailableJobsSuccessCopyWith<T, $Res> {
  __$$MyAvailableJobsSuccessCopyWithImpl(_$MyAvailableJobsSuccess<T> _value,
      $Res Function(_$MyAvailableJobsSuccess<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? myRequests = null,
  }) {
    return _then(_$MyAvailableJobsSuccess<T>(
      null == myRequests
          ? _value._myRequests
          : myRequests // ignore: cast_nullable_to_non_nullable
              as List<MyRequestModel>,
    ));
  }
}

/// @nodoc

class _$MyAvailableJobsSuccess<T> implements MyAvailableJobsSuccess<T> {
  const _$MyAvailableJobsSuccess(final List<MyRequestModel> myRequests)
      : _myRequests = myRequests;

  final List<MyRequestModel> _myRequests;
  @override
  List<MyRequestModel> get myRequests {
    if (_myRequests is EqualUnmodifiableListView) return _myRequests;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_myRequests);
  }

  @override
  String toString() {
    return 'RequestState<$T>.myAvailableJobsSuccess(myRequests: $myRequests)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyAvailableJobsSuccess<T> &&
            const DeepCollectionEquality()
                .equals(other._myRequests, _myRequests));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_myRequests));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyAvailableJobsSuccessCopyWith<T, _$MyAvailableJobsSuccess<T>>
      get copyWith => __$$MyAvailableJobsSuccessCopyWithImpl<T,
          _$MyAvailableJobsSuccess<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() myRequestsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myRequestsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myRequestsError,
    required TResult Function() offersLoading,
    required TResult Function(List<OfferModel> offers) offersSuccess,
    required TResult Function(NetworkExceptions networkExceptions) offersError,
    required TResult Function() myAvailableJobsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myAvailableJobsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myAvailableJobsError,
  }) {
    return myAvailableJobsSuccess(myRequests);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? myRequestsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult? Function()? offersLoading,
    TResult? Function(List<OfferModel> offers)? offersSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? offersError,
    TResult? Function()? myAvailableJobsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)?
        myAvailableJobsError,
  }) {
    return myAvailableJobsSuccess?.call(myRequests);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? myRequestsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult Function()? offersLoading,
    TResult Function(List<OfferModel> offers)? offersSuccess,
    TResult Function(NetworkExceptions networkExceptions)? offersError,
    TResult Function()? myAvailableJobsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (myAvailableJobsSuccess != null) {
      return myAvailableJobsSuccess(myRequests);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(MyRequestsLoading<T> value) myRequestsLoading,
    required TResult Function(MyRequestsSuccess<T> value) myRequestsSuccess,
    required TResult Function(MyRequestsError<T> value) myRequestsError,
    required TResult Function(OffersLoading<T> value) offersLoading,
    required TResult Function(OffersSuccess<T> value) offersSuccess,
    required TResult Function(OffersError<T> value) offersError,
    required TResult Function(MyAvailableJobsLoading<T> value)
        myAvailableJobsLoading,
    required TResult Function(MyAvailableJobsSuccess<T> value)
        myAvailableJobsSuccess,
    required TResult Function(MyAvailableJobsError<T> value)
        myAvailableJobsError,
  }) {
    return myAvailableJobsSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult? Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult? Function(MyRequestsError<T> value)? myRequestsError,
    TResult? Function(OffersLoading<T> value)? offersLoading,
    TResult? Function(OffersSuccess<T> value)? offersSuccess,
    TResult? Function(OffersError<T> value)? offersError,
    TResult? Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult? Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult? Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
  }) {
    return myAvailableJobsSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult Function(MyRequestsError<T> value)? myRequestsError,
    TResult Function(OffersLoading<T> value)? offersLoading,
    TResult Function(OffersSuccess<T> value)? offersSuccess,
    TResult Function(OffersError<T> value)? offersError,
    TResult Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (myAvailableJobsSuccess != null) {
      return myAvailableJobsSuccess(this);
    }
    return orElse();
  }
}

abstract class MyAvailableJobsSuccess<T> implements RequestState<T> {
  const factory MyAvailableJobsSuccess(final List<MyRequestModel> myRequests) =
      _$MyAvailableJobsSuccess<T>;

  List<MyRequestModel> get myRequests;
  @JsonKey(ignore: true)
  _$$MyAvailableJobsSuccessCopyWith<T, _$MyAvailableJobsSuccess<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MyAvailableJobsErrorCopyWith<T, $Res> {
  factory _$$MyAvailableJobsErrorCopyWith(_$MyAvailableJobsError<T> value,
          $Res Function(_$MyAvailableJobsError<T>) then) =
      __$$MyAvailableJobsErrorCopyWithImpl<T, $Res>;
  @useResult
  $Res call({NetworkExceptions networkExceptions});

  $NetworkExceptionsCopyWith<$Res> get networkExceptions;
}

/// @nodoc
class __$$MyAvailableJobsErrorCopyWithImpl<T, $Res>
    extends _$RequestStateCopyWithImpl<T, $Res, _$MyAvailableJobsError<T>>
    implements _$$MyAvailableJobsErrorCopyWith<T, $Res> {
  __$$MyAvailableJobsErrorCopyWithImpl(_$MyAvailableJobsError<T> _value,
      $Res Function(_$MyAvailableJobsError<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? networkExceptions = null,
  }) {
    return _then(_$MyAvailableJobsError<T>(
      null == networkExceptions
          ? _value.networkExceptions
          : networkExceptions // ignore: cast_nullable_to_non_nullable
              as NetworkExceptions,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NetworkExceptionsCopyWith<$Res> get networkExceptions {
    return $NetworkExceptionsCopyWith<$Res>(_value.networkExceptions, (value) {
      return _then(_value.copyWith(networkExceptions: value));
    });
  }
}

/// @nodoc

class _$MyAvailableJobsError<T> implements MyAvailableJobsError<T> {
  const _$MyAvailableJobsError(this.networkExceptions);

  @override
  final NetworkExceptions networkExceptions;

  @override
  String toString() {
    return 'RequestState<$T>.myAvailableJobsError(networkExceptions: $networkExceptions)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyAvailableJobsError<T> &&
            (identical(other.networkExceptions, networkExceptions) ||
                other.networkExceptions == networkExceptions));
  }

  @override
  int get hashCode => Object.hash(runtimeType, networkExceptions);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyAvailableJobsErrorCopyWith<T, _$MyAvailableJobsError<T>> get copyWith =>
      __$$MyAvailableJobsErrorCopyWithImpl<T, _$MyAvailableJobsError<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() myRequestsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myRequestsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myRequestsError,
    required TResult Function() offersLoading,
    required TResult Function(List<OfferModel> offers) offersSuccess,
    required TResult Function(NetworkExceptions networkExceptions) offersError,
    required TResult Function() myAvailableJobsLoading,
    required TResult Function(List<MyRequestModel> myRequests)
        myAvailableJobsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        myAvailableJobsError,
  }) {
    return myAvailableJobsError(networkExceptions);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? myRequestsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult? Function()? offersLoading,
    TResult? Function(List<OfferModel> offers)? offersSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? offersError,
    TResult? Function()? myAvailableJobsLoading,
    TResult? Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)?
        myAvailableJobsError,
  }) {
    return myAvailableJobsError?.call(networkExceptions);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? myRequestsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myRequestsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myRequestsError,
    TResult Function()? offersLoading,
    TResult Function(List<OfferModel> offers)? offersSuccess,
    TResult Function(NetworkExceptions networkExceptions)? offersError,
    TResult Function()? myAvailableJobsLoading,
    TResult Function(List<MyRequestModel> myRequests)? myAvailableJobsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (myAvailableJobsError != null) {
      return myAvailableJobsError(networkExceptions);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(MyRequestsLoading<T> value) myRequestsLoading,
    required TResult Function(MyRequestsSuccess<T> value) myRequestsSuccess,
    required TResult Function(MyRequestsError<T> value) myRequestsError,
    required TResult Function(OffersLoading<T> value) offersLoading,
    required TResult Function(OffersSuccess<T> value) offersSuccess,
    required TResult Function(OffersError<T> value) offersError,
    required TResult Function(MyAvailableJobsLoading<T> value)
        myAvailableJobsLoading,
    required TResult Function(MyAvailableJobsSuccess<T> value)
        myAvailableJobsSuccess,
    required TResult Function(MyAvailableJobsError<T> value)
        myAvailableJobsError,
  }) {
    return myAvailableJobsError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult? Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult? Function(MyRequestsError<T> value)? myRequestsError,
    TResult? Function(OffersLoading<T> value)? offersLoading,
    TResult? Function(OffersSuccess<T> value)? offersSuccess,
    TResult? Function(OffersError<T> value)? offersError,
    TResult? Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult? Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult? Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
  }) {
    return myAvailableJobsError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(MyRequestsLoading<T> value)? myRequestsLoading,
    TResult Function(MyRequestsSuccess<T> value)? myRequestsSuccess,
    TResult Function(MyRequestsError<T> value)? myRequestsError,
    TResult Function(OffersLoading<T> value)? offersLoading,
    TResult Function(OffersSuccess<T> value)? offersSuccess,
    TResult Function(OffersError<T> value)? offersError,
    TResult Function(MyAvailableJobsLoading<T> value)? myAvailableJobsLoading,
    TResult Function(MyAvailableJobsSuccess<T> value)? myAvailableJobsSuccess,
    TResult Function(MyAvailableJobsError<T> value)? myAvailableJobsError,
    required TResult orElse(),
  }) {
    if (myAvailableJobsError != null) {
      return myAvailableJobsError(this);
    }
    return orElse();
  }
}

abstract class MyAvailableJobsError<T> implements RequestState<T> {
  const factory MyAvailableJobsError(
      final NetworkExceptions networkExceptions) = _$MyAvailableJobsError<T>;

  NetworkExceptions get networkExceptions;
  @JsonKey(ignore: true)
  _$$MyAvailableJobsErrorCopyWith<T, _$MyAvailableJobsError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
