// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'menu_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$MenuState<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() walletInfoLoading,
    required TResult Function(WalletInfo data) walletInfoSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletInfoError,
    required TResult Function() userSkillsLoading,
    required TResult Function(List<SkillModel> skills) userSkillsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        userSkillsError,
    required TResult Function() updateSkillLoading,
    required TResult Function(UpdateSkill data) updateSkillSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        updateSkillError,
    required TResult Function() walletBlanceAddedLoading,
    required TResult Function(AddBalance data) walletBalanceAddedSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletBalanceAdddedError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? walletInfoLoading,
    TResult? Function(WalletInfo data)? walletInfoSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult? Function()? userSkillsLoading,
    TResult? Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult? Function()? updateSkillLoading,
    TResult? Function(UpdateSkill data)? updateSkillSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult? Function()? walletBlanceAddedLoading,
    TResult? Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? walletInfoLoading,
    TResult Function(WalletInfo data)? walletInfoSuccedded,
    TResult Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult Function()? userSkillsLoading,
    TResult Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult Function()? updateSkillLoading,
    TResult Function(UpdateSkill data)? updateSkillSuccess,
    TResult Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult Function()? walletBlanceAddedLoading,
    TResult Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(WalletInfoLoading<T> value) walletInfoLoading,
    required TResult Function(WalletInfoSuccedded<T> value) walletInfoSuccedded,
    required TResult Function(WalletInfoError<T> value) walletInfoError,
    required TResult Function(UserSkillsLoading<T> value) userSkillsLoading,
    required TResult Function(UserSkillsSuccess<T> value) userSkillsSuccess,
    required TResult Function(UserSkillsError<T> value) userSkillsError,
    required TResult Function(UpdateSkillLoading<T> value) updateSkillLoading,
    required TResult Function(UpdateSkillSuccess<T> value) updateSkillSuccess,
    required TResult Function(UpdateSkillError<T> value) updateSkillError,
    required TResult Function(WalletBlanceAddedLoading<T> value)
        walletBlanceAddedLoading,
    required TResult Function(WalletBalanceAddedSuccedded<T> value)
        walletBalanceAddedSuccedded,
    required TResult Function(WalletBalanceAdddedError<T> value)
        walletBalanceAdddedError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult? Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult? Function(WalletInfoError<T> value)? walletInfoError,
    TResult? Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult? Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult? Function(UserSkillsError<T> value)? userSkillsError,
    TResult? Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult? Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult? Function(UpdateSkillError<T> value)? updateSkillError,
    TResult? Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult? Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult? Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult Function(WalletInfoError<T> value)? walletInfoError,
    TResult Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult Function(UserSkillsError<T> value)? userSkillsError,
    TResult Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult Function(UpdateSkillError<T> value)? updateSkillError,
    TResult Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MenuStateCopyWith<T, $Res> {
  factory $MenuStateCopyWith(
          MenuState<T> value, $Res Function(MenuState<T>) then) =
      _$MenuStateCopyWithImpl<T, $Res, MenuState<T>>;
}

/// @nodoc
class _$MenuStateCopyWithImpl<T, $Res, $Val extends MenuState<T>>
    implements $MenuStateCopyWith<T, $Res> {
  _$MenuStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$IdleCopyWith<T, $Res> {
  factory _$$IdleCopyWith(_$Idle<T> value, $Res Function(_$Idle<T>) then) =
      __$$IdleCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$IdleCopyWithImpl<T, $Res>
    extends _$MenuStateCopyWithImpl<T, $Res, _$Idle<T>>
    implements _$$IdleCopyWith<T, $Res> {
  __$$IdleCopyWithImpl(_$Idle<T> _value, $Res Function(_$Idle<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Idle<T> implements Idle<T> {
  const _$Idle();

  @override
  String toString() {
    return 'MenuState<$T>.idle()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Idle<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() walletInfoLoading,
    required TResult Function(WalletInfo data) walletInfoSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletInfoError,
    required TResult Function() userSkillsLoading,
    required TResult Function(List<SkillModel> skills) userSkillsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        userSkillsError,
    required TResult Function() updateSkillLoading,
    required TResult Function(UpdateSkill data) updateSkillSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        updateSkillError,
    required TResult Function() walletBlanceAddedLoading,
    required TResult Function(AddBalance data) walletBalanceAddedSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletBalanceAdddedError,
  }) {
    return idle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? walletInfoLoading,
    TResult? Function(WalletInfo data)? walletInfoSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult? Function()? userSkillsLoading,
    TResult? Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult? Function()? updateSkillLoading,
    TResult? Function(UpdateSkill data)? updateSkillSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult? Function()? walletBlanceAddedLoading,
    TResult? Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
  }) {
    return idle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? walletInfoLoading,
    TResult Function(WalletInfo data)? walletInfoSuccedded,
    TResult Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult Function()? userSkillsLoading,
    TResult Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult Function()? updateSkillLoading,
    TResult Function(UpdateSkill data)? updateSkillSuccess,
    TResult Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult Function()? walletBlanceAddedLoading,
    TResult Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(WalletInfoLoading<T> value) walletInfoLoading,
    required TResult Function(WalletInfoSuccedded<T> value) walletInfoSuccedded,
    required TResult Function(WalletInfoError<T> value) walletInfoError,
    required TResult Function(UserSkillsLoading<T> value) userSkillsLoading,
    required TResult Function(UserSkillsSuccess<T> value) userSkillsSuccess,
    required TResult Function(UserSkillsError<T> value) userSkillsError,
    required TResult Function(UpdateSkillLoading<T> value) updateSkillLoading,
    required TResult Function(UpdateSkillSuccess<T> value) updateSkillSuccess,
    required TResult Function(UpdateSkillError<T> value) updateSkillError,
    required TResult Function(WalletBlanceAddedLoading<T> value)
        walletBlanceAddedLoading,
    required TResult Function(WalletBalanceAddedSuccedded<T> value)
        walletBalanceAddedSuccedded,
    required TResult Function(WalletBalanceAdddedError<T> value)
        walletBalanceAdddedError,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult? Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult? Function(WalletInfoError<T> value)? walletInfoError,
    TResult? Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult? Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult? Function(UserSkillsError<T> value)? userSkillsError,
    TResult? Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult? Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult? Function(UpdateSkillError<T> value)? updateSkillError,
    TResult? Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult? Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult? Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult Function(WalletInfoError<T> value)? walletInfoError,
    TResult Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult Function(UserSkillsError<T> value)? userSkillsError,
    TResult Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult Function(UpdateSkillError<T> value)? updateSkillError,
    TResult Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class Idle<T> implements MenuState<T> {
  const factory Idle() = _$Idle<T>;
}

/// @nodoc
abstract class _$$WalletInfoLoadingCopyWith<T, $Res> {
  factory _$$WalletInfoLoadingCopyWith(_$WalletInfoLoading<T> value,
          $Res Function(_$WalletInfoLoading<T>) then) =
      __$$WalletInfoLoadingCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$WalletInfoLoadingCopyWithImpl<T, $Res>
    extends _$MenuStateCopyWithImpl<T, $Res, _$WalletInfoLoading<T>>
    implements _$$WalletInfoLoadingCopyWith<T, $Res> {
  __$$WalletInfoLoadingCopyWithImpl(_$WalletInfoLoading<T> _value,
      $Res Function(_$WalletInfoLoading<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WalletInfoLoading<T> implements WalletInfoLoading<T> {
  const _$WalletInfoLoading();

  @override
  String toString() {
    return 'MenuState<$T>.walletInfoLoading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WalletInfoLoading<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() walletInfoLoading,
    required TResult Function(WalletInfo data) walletInfoSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletInfoError,
    required TResult Function() userSkillsLoading,
    required TResult Function(List<SkillModel> skills) userSkillsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        userSkillsError,
    required TResult Function() updateSkillLoading,
    required TResult Function(UpdateSkill data) updateSkillSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        updateSkillError,
    required TResult Function() walletBlanceAddedLoading,
    required TResult Function(AddBalance data) walletBalanceAddedSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletBalanceAdddedError,
  }) {
    return walletInfoLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? walletInfoLoading,
    TResult? Function(WalletInfo data)? walletInfoSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult? Function()? userSkillsLoading,
    TResult? Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult? Function()? updateSkillLoading,
    TResult? Function(UpdateSkill data)? updateSkillSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult? Function()? walletBlanceAddedLoading,
    TResult? Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
  }) {
    return walletInfoLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? walletInfoLoading,
    TResult Function(WalletInfo data)? walletInfoSuccedded,
    TResult Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult Function()? userSkillsLoading,
    TResult Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult Function()? updateSkillLoading,
    TResult Function(UpdateSkill data)? updateSkillSuccess,
    TResult Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult Function()? walletBlanceAddedLoading,
    TResult Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (walletInfoLoading != null) {
      return walletInfoLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(WalletInfoLoading<T> value) walletInfoLoading,
    required TResult Function(WalletInfoSuccedded<T> value) walletInfoSuccedded,
    required TResult Function(WalletInfoError<T> value) walletInfoError,
    required TResult Function(UserSkillsLoading<T> value) userSkillsLoading,
    required TResult Function(UserSkillsSuccess<T> value) userSkillsSuccess,
    required TResult Function(UserSkillsError<T> value) userSkillsError,
    required TResult Function(UpdateSkillLoading<T> value) updateSkillLoading,
    required TResult Function(UpdateSkillSuccess<T> value) updateSkillSuccess,
    required TResult Function(UpdateSkillError<T> value) updateSkillError,
    required TResult Function(WalletBlanceAddedLoading<T> value)
        walletBlanceAddedLoading,
    required TResult Function(WalletBalanceAddedSuccedded<T> value)
        walletBalanceAddedSuccedded,
    required TResult Function(WalletBalanceAdddedError<T> value)
        walletBalanceAdddedError,
  }) {
    return walletInfoLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult? Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult? Function(WalletInfoError<T> value)? walletInfoError,
    TResult? Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult? Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult? Function(UserSkillsError<T> value)? userSkillsError,
    TResult? Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult? Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult? Function(UpdateSkillError<T> value)? updateSkillError,
    TResult? Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult? Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult? Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
  }) {
    return walletInfoLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult Function(WalletInfoError<T> value)? walletInfoError,
    TResult Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult Function(UserSkillsError<T> value)? userSkillsError,
    TResult Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult Function(UpdateSkillError<T> value)? updateSkillError,
    TResult Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (walletInfoLoading != null) {
      return walletInfoLoading(this);
    }
    return orElse();
  }
}

abstract class WalletInfoLoading<T> implements MenuState<T> {
  const factory WalletInfoLoading() = _$WalletInfoLoading<T>;
}

/// @nodoc
abstract class _$$WalletInfoSucceddedCopyWith<T, $Res> {
  factory _$$WalletInfoSucceddedCopyWith(_$WalletInfoSuccedded<T> value,
          $Res Function(_$WalletInfoSuccedded<T>) then) =
      __$$WalletInfoSucceddedCopyWithImpl<T, $Res>;
  @useResult
  $Res call({WalletInfo data});
}

/// @nodoc
class __$$WalletInfoSucceddedCopyWithImpl<T, $Res>
    extends _$MenuStateCopyWithImpl<T, $Res, _$WalletInfoSuccedded<T>>
    implements _$$WalletInfoSucceddedCopyWith<T, $Res> {
  __$$WalletInfoSucceddedCopyWithImpl(_$WalletInfoSuccedded<T> _value,
      $Res Function(_$WalletInfoSuccedded<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$WalletInfoSuccedded<T>(
      null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as WalletInfo,
    ));
  }
}

/// @nodoc

class _$WalletInfoSuccedded<T> implements WalletInfoSuccedded<T> {
  const _$WalletInfoSuccedded(this.data);

  @override
  final WalletInfo data;

  @override
  String toString() {
    return 'MenuState<$T>.walletInfoSuccedded(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WalletInfoSuccedded<T> &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WalletInfoSucceddedCopyWith<T, _$WalletInfoSuccedded<T>> get copyWith =>
      __$$WalletInfoSucceddedCopyWithImpl<T, _$WalletInfoSuccedded<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() walletInfoLoading,
    required TResult Function(WalletInfo data) walletInfoSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletInfoError,
    required TResult Function() userSkillsLoading,
    required TResult Function(List<SkillModel> skills) userSkillsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        userSkillsError,
    required TResult Function() updateSkillLoading,
    required TResult Function(UpdateSkill data) updateSkillSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        updateSkillError,
    required TResult Function() walletBlanceAddedLoading,
    required TResult Function(AddBalance data) walletBalanceAddedSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletBalanceAdddedError,
  }) {
    return walletInfoSuccedded(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? walletInfoLoading,
    TResult? Function(WalletInfo data)? walletInfoSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult? Function()? userSkillsLoading,
    TResult? Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult? Function()? updateSkillLoading,
    TResult? Function(UpdateSkill data)? updateSkillSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult? Function()? walletBlanceAddedLoading,
    TResult? Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
  }) {
    return walletInfoSuccedded?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? walletInfoLoading,
    TResult Function(WalletInfo data)? walletInfoSuccedded,
    TResult Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult Function()? userSkillsLoading,
    TResult Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult Function()? updateSkillLoading,
    TResult Function(UpdateSkill data)? updateSkillSuccess,
    TResult Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult Function()? walletBlanceAddedLoading,
    TResult Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (walletInfoSuccedded != null) {
      return walletInfoSuccedded(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(WalletInfoLoading<T> value) walletInfoLoading,
    required TResult Function(WalletInfoSuccedded<T> value) walletInfoSuccedded,
    required TResult Function(WalletInfoError<T> value) walletInfoError,
    required TResult Function(UserSkillsLoading<T> value) userSkillsLoading,
    required TResult Function(UserSkillsSuccess<T> value) userSkillsSuccess,
    required TResult Function(UserSkillsError<T> value) userSkillsError,
    required TResult Function(UpdateSkillLoading<T> value) updateSkillLoading,
    required TResult Function(UpdateSkillSuccess<T> value) updateSkillSuccess,
    required TResult Function(UpdateSkillError<T> value) updateSkillError,
    required TResult Function(WalletBlanceAddedLoading<T> value)
        walletBlanceAddedLoading,
    required TResult Function(WalletBalanceAddedSuccedded<T> value)
        walletBalanceAddedSuccedded,
    required TResult Function(WalletBalanceAdddedError<T> value)
        walletBalanceAdddedError,
  }) {
    return walletInfoSuccedded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult? Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult? Function(WalletInfoError<T> value)? walletInfoError,
    TResult? Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult? Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult? Function(UserSkillsError<T> value)? userSkillsError,
    TResult? Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult? Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult? Function(UpdateSkillError<T> value)? updateSkillError,
    TResult? Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult? Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult? Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
  }) {
    return walletInfoSuccedded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult Function(WalletInfoError<T> value)? walletInfoError,
    TResult Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult Function(UserSkillsError<T> value)? userSkillsError,
    TResult Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult Function(UpdateSkillError<T> value)? updateSkillError,
    TResult Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (walletInfoSuccedded != null) {
      return walletInfoSuccedded(this);
    }
    return orElse();
  }
}

abstract class WalletInfoSuccedded<T> implements MenuState<T> {
  const factory WalletInfoSuccedded(final WalletInfo data) =
      _$WalletInfoSuccedded<T>;

  WalletInfo get data;
  @JsonKey(ignore: true)
  _$$WalletInfoSucceddedCopyWith<T, _$WalletInfoSuccedded<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WalletInfoErrorCopyWith<T, $Res> {
  factory _$$WalletInfoErrorCopyWith(_$WalletInfoError<T> value,
          $Res Function(_$WalletInfoError<T>) then) =
      __$$WalletInfoErrorCopyWithImpl<T, $Res>;
  @useResult
  $Res call({NetworkExceptions networkExceptions});

  $NetworkExceptionsCopyWith<$Res> get networkExceptions;
}

/// @nodoc
class __$$WalletInfoErrorCopyWithImpl<T, $Res>
    extends _$MenuStateCopyWithImpl<T, $Res, _$WalletInfoError<T>>
    implements _$$WalletInfoErrorCopyWith<T, $Res> {
  __$$WalletInfoErrorCopyWithImpl(
      _$WalletInfoError<T> _value, $Res Function(_$WalletInfoError<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? networkExceptions = null,
  }) {
    return _then(_$WalletInfoError<T>(
      null == networkExceptions
          ? _value.networkExceptions
          : networkExceptions // ignore: cast_nullable_to_non_nullable
              as NetworkExceptions,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NetworkExceptionsCopyWith<$Res> get networkExceptions {
    return $NetworkExceptionsCopyWith<$Res>(_value.networkExceptions, (value) {
      return _then(_value.copyWith(networkExceptions: value));
    });
  }
}

/// @nodoc

class _$WalletInfoError<T> implements WalletInfoError<T> {
  const _$WalletInfoError(this.networkExceptions);

  @override
  final NetworkExceptions networkExceptions;

  @override
  String toString() {
    return 'MenuState<$T>.walletInfoError(networkExceptions: $networkExceptions)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WalletInfoError<T> &&
            (identical(other.networkExceptions, networkExceptions) ||
                other.networkExceptions == networkExceptions));
  }

  @override
  int get hashCode => Object.hash(runtimeType, networkExceptions);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WalletInfoErrorCopyWith<T, _$WalletInfoError<T>> get copyWith =>
      __$$WalletInfoErrorCopyWithImpl<T, _$WalletInfoError<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() walletInfoLoading,
    required TResult Function(WalletInfo data) walletInfoSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletInfoError,
    required TResult Function() userSkillsLoading,
    required TResult Function(List<SkillModel> skills) userSkillsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        userSkillsError,
    required TResult Function() updateSkillLoading,
    required TResult Function(UpdateSkill data) updateSkillSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        updateSkillError,
    required TResult Function() walletBlanceAddedLoading,
    required TResult Function(AddBalance data) walletBalanceAddedSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletBalanceAdddedError,
  }) {
    return walletInfoError(networkExceptions);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? walletInfoLoading,
    TResult? Function(WalletInfo data)? walletInfoSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult? Function()? userSkillsLoading,
    TResult? Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult? Function()? updateSkillLoading,
    TResult? Function(UpdateSkill data)? updateSkillSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult? Function()? walletBlanceAddedLoading,
    TResult? Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
  }) {
    return walletInfoError?.call(networkExceptions);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? walletInfoLoading,
    TResult Function(WalletInfo data)? walletInfoSuccedded,
    TResult Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult Function()? userSkillsLoading,
    TResult Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult Function()? updateSkillLoading,
    TResult Function(UpdateSkill data)? updateSkillSuccess,
    TResult Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult Function()? walletBlanceAddedLoading,
    TResult Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (walletInfoError != null) {
      return walletInfoError(networkExceptions);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(WalletInfoLoading<T> value) walletInfoLoading,
    required TResult Function(WalletInfoSuccedded<T> value) walletInfoSuccedded,
    required TResult Function(WalletInfoError<T> value) walletInfoError,
    required TResult Function(UserSkillsLoading<T> value) userSkillsLoading,
    required TResult Function(UserSkillsSuccess<T> value) userSkillsSuccess,
    required TResult Function(UserSkillsError<T> value) userSkillsError,
    required TResult Function(UpdateSkillLoading<T> value) updateSkillLoading,
    required TResult Function(UpdateSkillSuccess<T> value) updateSkillSuccess,
    required TResult Function(UpdateSkillError<T> value) updateSkillError,
    required TResult Function(WalletBlanceAddedLoading<T> value)
        walletBlanceAddedLoading,
    required TResult Function(WalletBalanceAddedSuccedded<T> value)
        walletBalanceAddedSuccedded,
    required TResult Function(WalletBalanceAdddedError<T> value)
        walletBalanceAdddedError,
  }) {
    return walletInfoError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult? Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult? Function(WalletInfoError<T> value)? walletInfoError,
    TResult? Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult? Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult? Function(UserSkillsError<T> value)? userSkillsError,
    TResult? Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult? Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult? Function(UpdateSkillError<T> value)? updateSkillError,
    TResult? Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult? Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult? Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
  }) {
    return walletInfoError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult Function(WalletInfoError<T> value)? walletInfoError,
    TResult Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult Function(UserSkillsError<T> value)? userSkillsError,
    TResult Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult Function(UpdateSkillError<T> value)? updateSkillError,
    TResult Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (walletInfoError != null) {
      return walletInfoError(this);
    }
    return orElse();
  }
}

abstract class WalletInfoError<T> implements MenuState<T> {
  const factory WalletInfoError(final NetworkExceptions networkExceptions) =
      _$WalletInfoError<T>;

  NetworkExceptions get networkExceptions;
  @JsonKey(ignore: true)
  _$$WalletInfoErrorCopyWith<T, _$WalletInfoError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserSkillsLoadingCopyWith<T, $Res> {
  factory _$$UserSkillsLoadingCopyWith(_$UserSkillsLoading<T> value,
          $Res Function(_$UserSkillsLoading<T>) then) =
      __$$UserSkillsLoadingCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$UserSkillsLoadingCopyWithImpl<T, $Res>
    extends _$MenuStateCopyWithImpl<T, $Res, _$UserSkillsLoading<T>>
    implements _$$UserSkillsLoadingCopyWith<T, $Res> {
  __$$UserSkillsLoadingCopyWithImpl(_$UserSkillsLoading<T> _value,
      $Res Function(_$UserSkillsLoading<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserSkillsLoading<T> implements UserSkillsLoading<T> {
  const _$UserSkillsLoading();

  @override
  String toString() {
    return 'MenuState<$T>.userSkillsLoading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserSkillsLoading<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() walletInfoLoading,
    required TResult Function(WalletInfo data) walletInfoSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletInfoError,
    required TResult Function() userSkillsLoading,
    required TResult Function(List<SkillModel> skills) userSkillsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        userSkillsError,
    required TResult Function() updateSkillLoading,
    required TResult Function(UpdateSkill data) updateSkillSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        updateSkillError,
    required TResult Function() walletBlanceAddedLoading,
    required TResult Function(AddBalance data) walletBalanceAddedSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletBalanceAdddedError,
  }) {
    return userSkillsLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? walletInfoLoading,
    TResult? Function(WalletInfo data)? walletInfoSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult? Function()? userSkillsLoading,
    TResult? Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult? Function()? updateSkillLoading,
    TResult? Function(UpdateSkill data)? updateSkillSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult? Function()? walletBlanceAddedLoading,
    TResult? Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
  }) {
    return userSkillsLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? walletInfoLoading,
    TResult Function(WalletInfo data)? walletInfoSuccedded,
    TResult Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult Function()? userSkillsLoading,
    TResult Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult Function()? updateSkillLoading,
    TResult Function(UpdateSkill data)? updateSkillSuccess,
    TResult Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult Function()? walletBlanceAddedLoading,
    TResult Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (userSkillsLoading != null) {
      return userSkillsLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(WalletInfoLoading<T> value) walletInfoLoading,
    required TResult Function(WalletInfoSuccedded<T> value) walletInfoSuccedded,
    required TResult Function(WalletInfoError<T> value) walletInfoError,
    required TResult Function(UserSkillsLoading<T> value) userSkillsLoading,
    required TResult Function(UserSkillsSuccess<T> value) userSkillsSuccess,
    required TResult Function(UserSkillsError<T> value) userSkillsError,
    required TResult Function(UpdateSkillLoading<T> value) updateSkillLoading,
    required TResult Function(UpdateSkillSuccess<T> value) updateSkillSuccess,
    required TResult Function(UpdateSkillError<T> value) updateSkillError,
    required TResult Function(WalletBlanceAddedLoading<T> value)
        walletBlanceAddedLoading,
    required TResult Function(WalletBalanceAddedSuccedded<T> value)
        walletBalanceAddedSuccedded,
    required TResult Function(WalletBalanceAdddedError<T> value)
        walletBalanceAdddedError,
  }) {
    return userSkillsLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult? Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult? Function(WalletInfoError<T> value)? walletInfoError,
    TResult? Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult? Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult? Function(UserSkillsError<T> value)? userSkillsError,
    TResult? Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult? Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult? Function(UpdateSkillError<T> value)? updateSkillError,
    TResult? Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult? Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult? Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
  }) {
    return userSkillsLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult Function(WalletInfoError<T> value)? walletInfoError,
    TResult Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult Function(UserSkillsError<T> value)? userSkillsError,
    TResult Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult Function(UpdateSkillError<T> value)? updateSkillError,
    TResult Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (userSkillsLoading != null) {
      return userSkillsLoading(this);
    }
    return orElse();
  }
}

abstract class UserSkillsLoading<T> implements MenuState<T> {
  const factory UserSkillsLoading() = _$UserSkillsLoading<T>;
}

/// @nodoc
abstract class _$$UserSkillsSuccessCopyWith<T, $Res> {
  factory _$$UserSkillsSuccessCopyWith(_$UserSkillsSuccess<T> value,
          $Res Function(_$UserSkillsSuccess<T>) then) =
      __$$UserSkillsSuccessCopyWithImpl<T, $Res>;
  @useResult
  $Res call({List<SkillModel> skills});
}

/// @nodoc
class __$$UserSkillsSuccessCopyWithImpl<T, $Res>
    extends _$MenuStateCopyWithImpl<T, $Res, _$UserSkillsSuccess<T>>
    implements _$$UserSkillsSuccessCopyWith<T, $Res> {
  __$$UserSkillsSuccessCopyWithImpl(_$UserSkillsSuccess<T> _value,
      $Res Function(_$UserSkillsSuccess<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? skills = null,
  }) {
    return _then(_$UserSkillsSuccess<T>(
      null == skills
          ? _value._skills
          : skills // ignore: cast_nullable_to_non_nullable
              as List<SkillModel>,
    ));
  }
}

/// @nodoc

class _$UserSkillsSuccess<T> implements UserSkillsSuccess<T> {
  const _$UserSkillsSuccess(final List<SkillModel> skills) : _skills = skills;

  final List<SkillModel> _skills;
  @override
  List<SkillModel> get skills {
    if (_skills is EqualUnmodifiableListView) return _skills;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_skills);
  }

  @override
  String toString() {
    return 'MenuState<$T>.userSkillsSuccess(skills: $skills)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserSkillsSuccess<T> &&
            const DeepCollectionEquality().equals(other._skills, _skills));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_skills));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserSkillsSuccessCopyWith<T, _$UserSkillsSuccess<T>> get copyWith =>
      __$$UserSkillsSuccessCopyWithImpl<T, _$UserSkillsSuccess<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() walletInfoLoading,
    required TResult Function(WalletInfo data) walletInfoSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletInfoError,
    required TResult Function() userSkillsLoading,
    required TResult Function(List<SkillModel> skills) userSkillsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        userSkillsError,
    required TResult Function() updateSkillLoading,
    required TResult Function(UpdateSkill data) updateSkillSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        updateSkillError,
    required TResult Function() walletBlanceAddedLoading,
    required TResult Function(AddBalance data) walletBalanceAddedSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletBalanceAdddedError,
  }) {
    return userSkillsSuccess(skills);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? walletInfoLoading,
    TResult? Function(WalletInfo data)? walletInfoSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult? Function()? userSkillsLoading,
    TResult? Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult? Function()? updateSkillLoading,
    TResult? Function(UpdateSkill data)? updateSkillSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult? Function()? walletBlanceAddedLoading,
    TResult? Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
  }) {
    return userSkillsSuccess?.call(skills);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? walletInfoLoading,
    TResult Function(WalletInfo data)? walletInfoSuccedded,
    TResult Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult Function()? userSkillsLoading,
    TResult Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult Function()? updateSkillLoading,
    TResult Function(UpdateSkill data)? updateSkillSuccess,
    TResult Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult Function()? walletBlanceAddedLoading,
    TResult Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (userSkillsSuccess != null) {
      return userSkillsSuccess(skills);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(WalletInfoLoading<T> value) walletInfoLoading,
    required TResult Function(WalletInfoSuccedded<T> value) walletInfoSuccedded,
    required TResult Function(WalletInfoError<T> value) walletInfoError,
    required TResult Function(UserSkillsLoading<T> value) userSkillsLoading,
    required TResult Function(UserSkillsSuccess<T> value) userSkillsSuccess,
    required TResult Function(UserSkillsError<T> value) userSkillsError,
    required TResult Function(UpdateSkillLoading<T> value) updateSkillLoading,
    required TResult Function(UpdateSkillSuccess<T> value) updateSkillSuccess,
    required TResult Function(UpdateSkillError<T> value) updateSkillError,
    required TResult Function(WalletBlanceAddedLoading<T> value)
        walletBlanceAddedLoading,
    required TResult Function(WalletBalanceAddedSuccedded<T> value)
        walletBalanceAddedSuccedded,
    required TResult Function(WalletBalanceAdddedError<T> value)
        walletBalanceAdddedError,
  }) {
    return userSkillsSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult? Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult? Function(WalletInfoError<T> value)? walletInfoError,
    TResult? Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult? Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult? Function(UserSkillsError<T> value)? userSkillsError,
    TResult? Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult? Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult? Function(UpdateSkillError<T> value)? updateSkillError,
    TResult? Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult? Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult? Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
  }) {
    return userSkillsSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult Function(WalletInfoError<T> value)? walletInfoError,
    TResult Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult Function(UserSkillsError<T> value)? userSkillsError,
    TResult Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult Function(UpdateSkillError<T> value)? updateSkillError,
    TResult Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (userSkillsSuccess != null) {
      return userSkillsSuccess(this);
    }
    return orElse();
  }
}

abstract class UserSkillsSuccess<T> implements MenuState<T> {
  const factory UserSkillsSuccess(final List<SkillModel> skills) =
      _$UserSkillsSuccess<T>;

  List<SkillModel> get skills;
  @JsonKey(ignore: true)
  _$$UserSkillsSuccessCopyWith<T, _$UserSkillsSuccess<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UserSkillsErrorCopyWith<T, $Res> {
  factory _$$UserSkillsErrorCopyWith(_$UserSkillsError<T> value,
          $Res Function(_$UserSkillsError<T>) then) =
      __$$UserSkillsErrorCopyWithImpl<T, $Res>;
  @useResult
  $Res call({NetworkExceptions networkExceptions});

  $NetworkExceptionsCopyWith<$Res> get networkExceptions;
}

/// @nodoc
class __$$UserSkillsErrorCopyWithImpl<T, $Res>
    extends _$MenuStateCopyWithImpl<T, $Res, _$UserSkillsError<T>>
    implements _$$UserSkillsErrorCopyWith<T, $Res> {
  __$$UserSkillsErrorCopyWithImpl(
      _$UserSkillsError<T> _value, $Res Function(_$UserSkillsError<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? networkExceptions = null,
  }) {
    return _then(_$UserSkillsError<T>(
      null == networkExceptions
          ? _value.networkExceptions
          : networkExceptions // ignore: cast_nullable_to_non_nullable
              as NetworkExceptions,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NetworkExceptionsCopyWith<$Res> get networkExceptions {
    return $NetworkExceptionsCopyWith<$Res>(_value.networkExceptions, (value) {
      return _then(_value.copyWith(networkExceptions: value));
    });
  }
}

/// @nodoc

class _$UserSkillsError<T> implements UserSkillsError<T> {
  const _$UserSkillsError(this.networkExceptions);

  @override
  final NetworkExceptions networkExceptions;

  @override
  String toString() {
    return 'MenuState<$T>.userSkillsError(networkExceptions: $networkExceptions)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UserSkillsError<T> &&
            (identical(other.networkExceptions, networkExceptions) ||
                other.networkExceptions == networkExceptions));
  }

  @override
  int get hashCode => Object.hash(runtimeType, networkExceptions);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserSkillsErrorCopyWith<T, _$UserSkillsError<T>> get copyWith =>
      __$$UserSkillsErrorCopyWithImpl<T, _$UserSkillsError<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() walletInfoLoading,
    required TResult Function(WalletInfo data) walletInfoSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletInfoError,
    required TResult Function() userSkillsLoading,
    required TResult Function(List<SkillModel> skills) userSkillsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        userSkillsError,
    required TResult Function() updateSkillLoading,
    required TResult Function(UpdateSkill data) updateSkillSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        updateSkillError,
    required TResult Function() walletBlanceAddedLoading,
    required TResult Function(AddBalance data) walletBalanceAddedSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletBalanceAdddedError,
  }) {
    return userSkillsError(networkExceptions);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? walletInfoLoading,
    TResult? Function(WalletInfo data)? walletInfoSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult? Function()? userSkillsLoading,
    TResult? Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult? Function()? updateSkillLoading,
    TResult? Function(UpdateSkill data)? updateSkillSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult? Function()? walletBlanceAddedLoading,
    TResult? Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
  }) {
    return userSkillsError?.call(networkExceptions);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? walletInfoLoading,
    TResult Function(WalletInfo data)? walletInfoSuccedded,
    TResult Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult Function()? userSkillsLoading,
    TResult Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult Function()? updateSkillLoading,
    TResult Function(UpdateSkill data)? updateSkillSuccess,
    TResult Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult Function()? walletBlanceAddedLoading,
    TResult Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (userSkillsError != null) {
      return userSkillsError(networkExceptions);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(WalletInfoLoading<T> value) walletInfoLoading,
    required TResult Function(WalletInfoSuccedded<T> value) walletInfoSuccedded,
    required TResult Function(WalletInfoError<T> value) walletInfoError,
    required TResult Function(UserSkillsLoading<T> value) userSkillsLoading,
    required TResult Function(UserSkillsSuccess<T> value) userSkillsSuccess,
    required TResult Function(UserSkillsError<T> value) userSkillsError,
    required TResult Function(UpdateSkillLoading<T> value) updateSkillLoading,
    required TResult Function(UpdateSkillSuccess<T> value) updateSkillSuccess,
    required TResult Function(UpdateSkillError<T> value) updateSkillError,
    required TResult Function(WalletBlanceAddedLoading<T> value)
        walletBlanceAddedLoading,
    required TResult Function(WalletBalanceAddedSuccedded<T> value)
        walletBalanceAddedSuccedded,
    required TResult Function(WalletBalanceAdddedError<T> value)
        walletBalanceAdddedError,
  }) {
    return userSkillsError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult? Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult? Function(WalletInfoError<T> value)? walletInfoError,
    TResult? Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult? Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult? Function(UserSkillsError<T> value)? userSkillsError,
    TResult? Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult? Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult? Function(UpdateSkillError<T> value)? updateSkillError,
    TResult? Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult? Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult? Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
  }) {
    return userSkillsError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult Function(WalletInfoError<T> value)? walletInfoError,
    TResult Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult Function(UserSkillsError<T> value)? userSkillsError,
    TResult Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult Function(UpdateSkillError<T> value)? updateSkillError,
    TResult Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (userSkillsError != null) {
      return userSkillsError(this);
    }
    return orElse();
  }
}

abstract class UserSkillsError<T> implements MenuState<T> {
  const factory UserSkillsError(final NetworkExceptions networkExceptions) =
      _$UserSkillsError<T>;

  NetworkExceptions get networkExceptions;
  @JsonKey(ignore: true)
  _$$UserSkillsErrorCopyWith<T, _$UserSkillsError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateSkillLoadingCopyWith<T, $Res> {
  factory _$$UpdateSkillLoadingCopyWith(_$UpdateSkillLoading<T> value,
          $Res Function(_$UpdateSkillLoading<T>) then) =
      __$$UpdateSkillLoadingCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$UpdateSkillLoadingCopyWithImpl<T, $Res>
    extends _$MenuStateCopyWithImpl<T, $Res, _$UpdateSkillLoading<T>>
    implements _$$UpdateSkillLoadingCopyWith<T, $Res> {
  __$$UpdateSkillLoadingCopyWithImpl(_$UpdateSkillLoading<T> _value,
      $Res Function(_$UpdateSkillLoading<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UpdateSkillLoading<T> implements UpdateSkillLoading<T> {
  const _$UpdateSkillLoading();

  @override
  String toString() {
    return 'MenuState<$T>.updateSkillLoading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UpdateSkillLoading<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() walletInfoLoading,
    required TResult Function(WalletInfo data) walletInfoSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletInfoError,
    required TResult Function() userSkillsLoading,
    required TResult Function(List<SkillModel> skills) userSkillsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        userSkillsError,
    required TResult Function() updateSkillLoading,
    required TResult Function(UpdateSkill data) updateSkillSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        updateSkillError,
    required TResult Function() walletBlanceAddedLoading,
    required TResult Function(AddBalance data) walletBalanceAddedSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletBalanceAdddedError,
  }) {
    return updateSkillLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? walletInfoLoading,
    TResult? Function(WalletInfo data)? walletInfoSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult? Function()? userSkillsLoading,
    TResult? Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult? Function()? updateSkillLoading,
    TResult? Function(UpdateSkill data)? updateSkillSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult? Function()? walletBlanceAddedLoading,
    TResult? Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
  }) {
    return updateSkillLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? walletInfoLoading,
    TResult Function(WalletInfo data)? walletInfoSuccedded,
    TResult Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult Function()? userSkillsLoading,
    TResult Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult Function()? updateSkillLoading,
    TResult Function(UpdateSkill data)? updateSkillSuccess,
    TResult Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult Function()? walletBlanceAddedLoading,
    TResult Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (updateSkillLoading != null) {
      return updateSkillLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(WalletInfoLoading<T> value) walletInfoLoading,
    required TResult Function(WalletInfoSuccedded<T> value) walletInfoSuccedded,
    required TResult Function(WalletInfoError<T> value) walletInfoError,
    required TResult Function(UserSkillsLoading<T> value) userSkillsLoading,
    required TResult Function(UserSkillsSuccess<T> value) userSkillsSuccess,
    required TResult Function(UserSkillsError<T> value) userSkillsError,
    required TResult Function(UpdateSkillLoading<T> value) updateSkillLoading,
    required TResult Function(UpdateSkillSuccess<T> value) updateSkillSuccess,
    required TResult Function(UpdateSkillError<T> value) updateSkillError,
    required TResult Function(WalletBlanceAddedLoading<T> value)
        walletBlanceAddedLoading,
    required TResult Function(WalletBalanceAddedSuccedded<T> value)
        walletBalanceAddedSuccedded,
    required TResult Function(WalletBalanceAdddedError<T> value)
        walletBalanceAdddedError,
  }) {
    return updateSkillLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult? Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult? Function(WalletInfoError<T> value)? walletInfoError,
    TResult? Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult? Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult? Function(UserSkillsError<T> value)? userSkillsError,
    TResult? Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult? Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult? Function(UpdateSkillError<T> value)? updateSkillError,
    TResult? Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult? Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult? Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
  }) {
    return updateSkillLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult Function(WalletInfoError<T> value)? walletInfoError,
    TResult Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult Function(UserSkillsError<T> value)? userSkillsError,
    TResult Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult Function(UpdateSkillError<T> value)? updateSkillError,
    TResult Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (updateSkillLoading != null) {
      return updateSkillLoading(this);
    }
    return orElse();
  }
}

abstract class UpdateSkillLoading<T> implements MenuState<T> {
  const factory UpdateSkillLoading() = _$UpdateSkillLoading<T>;
}

/// @nodoc
abstract class _$$UpdateSkillSuccessCopyWith<T, $Res> {
  factory _$$UpdateSkillSuccessCopyWith(_$UpdateSkillSuccess<T> value,
          $Res Function(_$UpdateSkillSuccess<T>) then) =
      __$$UpdateSkillSuccessCopyWithImpl<T, $Res>;
  @useResult
  $Res call({UpdateSkill data});
}

/// @nodoc
class __$$UpdateSkillSuccessCopyWithImpl<T, $Res>
    extends _$MenuStateCopyWithImpl<T, $Res, _$UpdateSkillSuccess<T>>
    implements _$$UpdateSkillSuccessCopyWith<T, $Res> {
  __$$UpdateSkillSuccessCopyWithImpl(_$UpdateSkillSuccess<T> _value,
      $Res Function(_$UpdateSkillSuccess<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$UpdateSkillSuccess<T>(
      null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as UpdateSkill,
    ));
  }
}

/// @nodoc

class _$UpdateSkillSuccess<T> implements UpdateSkillSuccess<T> {
  const _$UpdateSkillSuccess(this.data);

  @override
  final UpdateSkill data;

  @override
  String toString() {
    return 'MenuState<$T>.updateSkillSuccess(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateSkillSuccess<T> &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateSkillSuccessCopyWith<T, _$UpdateSkillSuccess<T>> get copyWith =>
      __$$UpdateSkillSuccessCopyWithImpl<T, _$UpdateSkillSuccess<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() walletInfoLoading,
    required TResult Function(WalletInfo data) walletInfoSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletInfoError,
    required TResult Function() userSkillsLoading,
    required TResult Function(List<SkillModel> skills) userSkillsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        userSkillsError,
    required TResult Function() updateSkillLoading,
    required TResult Function(UpdateSkill data) updateSkillSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        updateSkillError,
    required TResult Function() walletBlanceAddedLoading,
    required TResult Function(AddBalance data) walletBalanceAddedSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletBalanceAdddedError,
  }) {
    return updateSkillSuccess(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? walletInfoLoading,
    TResult? Function(WalletInfo data)? walletInfoSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult? Function()? userSkillsLoading,
    TResult? Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult? Function()? updateSkillLoading,
    TResult? Function(UpdateSkill data)? updateSkillSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult? Function()? walletBlanceAddedLoading,
    TResult? Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
  }) {
    return updateSkillSuccess?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? walletInfoLoading,
    TResult Function(WalletInfo data)? walletInfoSuccedded,
    TResult Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult Function()? userSkillsLoading,
    TResult Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult Function()? updateSkillLoading,
    TResult Function(UpdateSkill data)? updateSkillSuccess,
    TResult Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult Function()? walletBlanceAddedLoading,
    TResult Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (updateSkillSuccess != null) {
      return updateSkillSuccess(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(WalletInfoLoading<T> value) walletInfoLoading,
    required TResult Function(WalletInfoSuccedded<T> value) walletInfoSuccedded,
    required TResult Function(WalletInfoError<T> value) walletInfoError,
    required TResult Function(UserSkillsLoading<T> value) userSkillsLoading,
    required TResult Function(UserSkillsSuccess<T> value) userSkillsSuccess,
    required TResult Function(UserSkillsError<T> value) userSkillsError,
    required TResult Function(UpdateSkillLoading<T> value) updateSkillLoading,
    required TResult Function(UpdateSkillSuccess<T> value) updateSkillSuccess,
    required TResult Function(UpdateSkillError<T> value) updateSkillError,
    required TResult Function(WalletBlanceAddedLoading<T> value)
        walletBlanceAddedLoading,
    required TResult Function(WalletBalanceAddedSuccedded<T> value)
        walletBalanceAddedSuccedded,
    required TResult Function(WalletBalanceAdddedError<T> value)
        walletBalanceAdddedError,
  }) {
    return updateSkillSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult? Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult? Function(WalletInfoError<T> value)? walletInfoError,
    TResult? Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult? Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult? Function(UserSkillsError<T> value)? userSkillsError,
    TResult? Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult? Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult? Function(UpdateSkillError<T> value)? updateSkillError,
    TResult? Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult? Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult? Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
  }) {
    return updateSkillSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult Function(WalletInfoError<T> value)? walletInfoError,
    TResult Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult Function(UserSkillsError<T> value)? userSkillsError,
    TResult Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult Function(UpdateSkillError<T> value)? updateSkillError,
    TResult Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (updateSkillSuccess != null) {
      return updateSkillSuccess(this);
    }
    return orElse();
  }
}

abstract class UpdateSkillSuccess<T> implements MenuState<T> {
  const factory UpdateSkillSuccess(final UpdateSkill data) =
      _$UpdateSkillSuccess<T>;

  UpdateSkill get data;
  @JsonKey(ignore: true)
  _$$UpdateSkillSuccessCopyWith<T, _$UpdateSkillSuccess<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateSkillErrorCopyWith<T, $Res> {
  factory _$$UpdateSkillErrorCopyWith(_$UpdateSkillError<T> value,
          $Res Function(_$UpdateSkillError<T>) then) =
      __$$UpdateSkillErrorCopyWithImpl<T, $Res>;
  @useResult
  $Res call({NetworkExceptions networkExceptions});

  $NetworkExceptionsCopyWith<$Res> get networkExceptions;
}

/// @nodoc
class __$$UpdateSkillErrorCopyWithImpl<T, $Res>
    extends _$MenuStateCopyWithImpl<T, $Res, _$UpdateSkillError<T>>
    implements _$$UpdateSkillErrorCopyWith<T, $Res> {
  __$$UpdateSkillErrorCopyWithImpl(
      _$UpdateSkillError<T> _value, $Res Function(_$UpdateSkillError<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? networkExceptions = null,
  }) {
    return _then(_$UpdateSkillError<T>(
      null == networkExceptions
          ? _value.networkExceptions
          : networkExceptions // ignore: cast_nullable_to_non_nullable
              as NetworkExceptions,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NetworkExceptionsCopyWith<$Res> get networkExceptions {
    return $NetworkExceptionsCopyWith<$Res>(_value.networkExceptions, (value) {
      return _then(_value.copyWith(networkExceptions: value));
    });
  }
}

/// @nodoc

class _$UpdateSkillError<T> implements UpdateSkillError<T> {
  const _$UpdateSkillError(this.networkExceptions);

  @override
  final NetworkExceptions networkExceptions;

  @override
  String toString() {
    return 'MenuState<$T>.updateSkillError(networkExceptions: $networkExceptions)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateSkillError<T> &&
            (identical(other.networkExceptions, networkExceptions) ||
                other.networkExceptions == networkExceptions));
  }

  @override
  int get hashCode => Object.hash(runtimeType, networkExceptions);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateSkillErrorCopyWith<T, _$UpdateSkillError<T>> get copyWith =>
      __$$UpdateSkillErrorCopyWithImpl<T, _$UpdateSkillError<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() walletInfoLoading,
    required TResult Function(WalletInfo data) walletInfoSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletInfoError,
    required TResult Function() userSkillsLoading,
    required TResult Function(List<SkillModel> skills) userSkillsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        userSkillsError,
    required TResult Function() updateSkillLoading,
    required TResult Function(UpdateSkill data) updateSkillSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        updateSkillError,
    required TResult Function() walletBlanceAddedLoading,
    required TResult Function(AddBalance data) walletBalanceAddedSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletBalanceAdddedError,
  }) {
    return updateSkillError(networkExceptions);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? walletInfoLoading,
    TResult? Function(WalletInfo data)? walletInfoSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult? Function()? userSkillsLoading,
    TResult? Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult? Function()? updateSkillLoading,
    TResult? Function(UpdateSkill data)? updateSkillSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult? Function()? walletBlanceAddedLoading,
    TResult? Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
  }) {
    return updateSkillError?.call(networkExceptions);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? walletInfoLoading,
    TResult Function(WalletInfo data)? walletInfoSuccedded,
    TResult Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult Function()? userSkillsLoading,
    TResult Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult Function()? updateSkillLoading,
    TResult Function(UpdateSkill data)? updateSkillSuccess,
    TResult Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult Function()? walletBlanceAddedLoading,
    TResult Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (updateSkillError != null) {
      return updateSkillError(networkExceptions);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(WalletInfoLoading<T> value) walletInfoLoading,
    required TResult Function(WalletInfoSuccedded<T> value) walletInfoSuccedded,
    required TResult Function(WalletInfoError<T> value) walletInfoError,
    required TResult Function(UserSkillsLoading<T> value) userSkillsLoading,
    required TResult Function(UserSkillsSuccess<T> value) userSkillsSuccess,
    required TResult Function(UserSkillsError<T> value) userSkillsError,
    required TResult Function(UpdateSkillLoading<T> value) updateSkillLoading,
    required TResult Function(UpdateSkillSuccess<T> value) updateSkillSuccess,
    required TResult Function(UpdateSkillError<T> value) updateSkillError,
    required TResult Function(WalletBlanceAddedLoading<T> value)
        walletBlanceAddedLoading,
    required TResult Function(WalletBalanceAddedSuccedded<T> value)
        walletBalanceAddedSuccedded,
    required TResult Function(WalletBalanceAdddedError<T> value)
        walletBalanceAdddedError,
  }) {
    return updateSkillError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult? Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult? Function(WalletInfoError<T> value)? walletInfoError,
    TResult? Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult? Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult? Function(UserSkillsError<T> value)? userSkillsError,
    TResult? Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult? Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult? Function(UpdateSkillError<T> value)? updateSkillError,
    TResult? Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult? Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult? Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
  }) {
    return updateSkillError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult Function(WalletInfoError<T> value)? walletInfoError,
    TResult Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult Function(UserSkillsError<T> value)? userSkillsError,
    TResult Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult Function(UpdateSkillError<T> value)? updateSkillError,
    TResult Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (updateSkillError != null) {
      return updateSkillError(this);
    }
    return orElse();
  }
}

abstract class UpdateSkillError<T> implements MenuState<T> {
  const factory UpdateSkillError(final NetworkExceptions networkExceptions) =
      _$UpdateSkillError<T>;

  NetworkExceptions get networkExceptions;
  @JsonKey(ignore: true)
  _$$UpdateSkillErrorCopyWith<T, _$UpdateSkillError<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WalletBlanceAddedLoadingCopyWith<T, $Res> {
  factory _$$WalletBlanceAddedLoadingCopyWith(
          _$WalletBlanceAddedLoading<T> value,
          $Res Function(_$WalletBlanceAddedLoading<T>) then) =
      __$$WalletBlanceAddedLoadingCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$WalletBlanceAddedLoadingCopyWithImpl<T, $Res>
    extends _$MenuStateCopyWithImpl<T, $Res, _$WalletBlanceAddedLoading<T>>
    implements _$$WalletBlanceAddedLoadingCopyWith<T, $Res> {
  __$$WalletBlanceAddedLoadingCopyWithImpl(_$WalletBlanceAddedLoading<T> _value,
      $Res Function(_$WalletBlanceAddedLoading<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WalletBlanceAddedLoading<T> implements WalletBlanceAddedLoading<T> {
  const _$WalletBlanceAddedLoading();

  @override
  String toString() {
    return 'MenuState<$T>.walletBlanceAddedLoading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WalletBlanceAddedLoading<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() walletInfoLoading,
    required TResult Function(WalletInfo data) walletInfoSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletInfoError,
    required TResult Function() userSkillsLoading,
    required TResult Function(List<SkillModel> skills) userSkillsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        userSkillsError,
    required TResult Function() updateSkillLoading,
    required TResult Function(UpdateSkill data) updateSkillSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        updateSkillError,
    required TResult Function() walletBlanceAddedLoading,
    required TResult Function(AddBalance data) walletBalanceAddedSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletBalanceAdddedError,
  }) {
    return walletBlanceAddedLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? walletInfoLoading,
    TResult? Function(WalletInfo data)? walletInfoSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult? Function()? userSkillsLoading,
    TResult? Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult? Function()? updateSkillLoading,
    TResult? Function(UpdateSkill data)? updateSkillSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult? Function()? walletBlanceAddedLoading,
    TResult? Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
  }) {
    return walletBlanceAddedLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? walletInfoLoading,
    TResult Function(WalletInfo data)? walletInfoSuccedded,
    TResult Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult Function()? userSkillsLoading,
    TResult Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult Function()? updateSkillLoading,
    TResult Function(UpdateSkill data)? updateSkillSuccess,
    TResult Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult Function()? walletBlanceAddedLoading,
    TResult Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (walletBlanceAddedLoading != null) {
      return walletBlanceAddedLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(WalletInfoLoading<T> value) walletInfoLoading,
    required TResult Function(WalletInfoSuccedded<T> value) walletInfoSuccedded,
    required TResult Function(WalletInfoError<T> value) walletInfoError,
    required TResult Function(UserSkillsLoading<T> value) userSkillsLoading,
    required TResult Function(UserSkillsSuccess<T> value) userSkillsSuccess,
    required TResult Function(UserSkillsError<T> value) userSkillsError,
    required TResult Function(UpdateSkillLoading<T> value) updateSkillLoading,
    required TResult Function(UpdateSkillSuccess<T> value) updateSkillSuccess,
    required TResult Function(UpdateSkillError<T> value) updateSkillError,
    required TResult Function(WalletBlanceAddedLoading<T> value)
        walletBlanceAddedLoading,
    required TResult Function(WalletBalanceAddedSuccedded<T> value)
        walletBalanceAddedSuccedded,
    required TResult Function(WalletBalanceAdddedError<T> value)
        walletBalanceAdddedError,
  }) {
    return walletBlanceAddedLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult? Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult? Function(WalletInfoError<T> value)? walletInfoError,
    TResult? Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult? Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult? Function(UserSkillsError<T> value)? userSkillsError,
    TResult? Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult? Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult? Function(UpdateSkillError<T> value)? updateSkillError,
    TResult? Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult? Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult? Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
  }) {
    return walletBlanceAddedLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult Function(WalletInfoError<T> value)? walletInfoError,
    TResult Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult Function(UserSkillsError<T> value)? userSkillsError,
    TResult Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult Function(UpdateSkillError<T> value)? updateSkillError,
    TResult Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (walletBlanceAddedLoading != null) {
      return walletBlanceAddedLoading(this);
    }
    return orElse();
  }
}

abstract class WalletBlanceAddedLoading<T> implements MenuState<T> {
  const factory WalletBlanceAddedLoading() = _$WalletBlanceAddedLoading<T>;
}

/// @nodoc
abstract class _$$WalletBalanceAddedSucceddedCopyWith<T, $Res> {
  factory _$$WalletBalanceAddedSucceddedCopyWith(
          _$WalletBalanceAddedSuccedded<T> value,
          $Res Function(_$WalletBalanceAddedSuccedded<T>) then) =
      __$$WalletBalanceAddedSucceddedCopyWithImpl<T, $Res>;
  @useResult
  $Res call({AddBalance data});
}

/// @nodoc
class __$$WalletBalanceAddedSucceddedCopyWithImpl<T, $Res>
    extends _$MenuStateCopyWithImpl<T, $Res, _$WalletBalanceAddedSuccedded<T>>
    implements _$$WalletBalanceAddedSucceddedCopyWith<T, $Res> {
  __$$WalletBalanceAddedSucceddedCopyWithImpl(
      _$WalletBalanceAddedSuccedded<T> _value,
      $Res Function(_$WalletBalanceAddedSuccedded<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$WalletBalanceAddedSuccedded<T>(
      null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as AddBalance,
    ));
  }
}

/// @nodoc

class _$WalletBalanceAddedSuccedded<T>
    implements WalletBalanceAddedSuccedded<T> {
  const _$WalletBalanceAddedSuccedded(this.data);

  @override
  final AddBalance data;

  @override
  String toString() {
    return 'MenuState<$T>.walletBalanceAddedSuccedded(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WalletBalanceAddedSuccedded<T> &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WalletBalanceAddedSucceddedCopyWith<T, _$WalletBalanceAddedSuccedded<T>>
      get copyWith => __$$WalletBalanceAddedSucceddedCopyWithImpl<T,
          _$WalletBalanceAddedSuccedded<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() walletInfoLoading,
    required TResult Function(WalletInfo data) walletInfoSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletInfoError,
    required TResult Function() userSkillsLoading,
    required TResult Function(List<SkillModel> skills) userSkillsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        userSkillsError,
    required TResult Function() updateSkillLoading,
    required TResult Function(UpdateSkill data) updateSkillSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        updateSkillError,
    required TResult Function() walletBlanceAddedLoading,
    required TResult Function(AddBalance data) walletBalanceAddedSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletBalanceAdddedError,
  }) {
    return walletBalanceAddedSuccedded(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? walletInfoLoading,
    TResult? Function(WalletInfo data)? walletInfoSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult? Function()? userSkillsLoading,
    TResult? Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult? Function()? updateSkillLoading,
    TResult? Function(UpdateSkill data)? updateSkillSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult? Function()? walletBlanceAddedLoading,
    TResult? Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
  }) {
    return walletBalanceAddedSuccedded?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? walletInfoLoading,
    TResult Function(WalletInfo data)? walletInfoSuccedded,
    TResult Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult Function()? userSkillsLoading,
    TResult Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult Function()? updateSkillLoading,
    TResult Function(UpdateSkill data)? updateSkillSuccess,
    TResult Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult Function()? walletBlanceAddedLoading,
    TResult Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (walletBalanceAddedSuccedded != null) {
      return walletBalanceAddedSuccedded(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(WalletInfoLoading<T> value) walletInfoLoading,
    required TResult Function(WalletInfoSuccedded<T> value) walletInfoSuccedded,
    required TResult Function(WalletInfoError<T> value) walletInfoError,
    required TResult Function(UserSkillsLoading<T> value) userSkillsLoading,
    required TResult Function(UserSkillsSuccess<T> value) userSkillsSuccess,
    required TResult Function(UserSkillsError<T> value) userSkillsError,
    required TResult Function(UpdateSkillLoading<T> value) updateSkillLoading,
    required TResult Function(UpdateSkillSuccess<T> value) updateSkillSuccess,
    required TResult Function(UpdateSkillError<T> value) updateSkillError,
    required TResult Function(WalletBlanceAddedLoading<T> value)
        walletBlanceAddedLoading,
    required TResult Function(WalletBalanceAddedSuccedded<T> value)
        walletBalanceAddedSuccedded,
    required TResult Function(WalletBalanceAdddedError<T> value)
        walletBalanceAdddedError,
  }) {
    return walletBalanceAddedSuccedded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult? Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult? Function(WalletInfoError<T> value)? walletInfoError,
    TResult? Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult? Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult? Function(UserSkillsError<T> value)? userSkillsError,
    TResult? Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult? Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult? Function(UpdateSkillError<T> value)? updateSkillError,
    TResult? Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult? Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult? Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
  }) {
    return walletBalanceAddedSuccedded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult Function(WalletInfoError<T> value)? walletInfoError,
    TResult Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult Function(UserSkillsError<T> value)? userSkillsError,
    TResult Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult Function(UpdateSkillError<T> value)? updateSkillError,
    TResult Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (walletBalanceAddedSuccedded != null) {
      return walletBalanceAddedSuccedded(this);
    }
    return orElse();
  }
}

abstract class WalletBalanceAddedSuccedded<T> implements MenuState<T> {
  const factory WalletBalanceAddedSuccedded(final AddBalance data) =
      _$WalletBalanceAddedSuccedded<T>;

  AddBalance get data;
  @JsonKey(ignore: true)
  _$$WalletBalanceAddedSucceddedCopyWith<T, _$WalletBalanceAddedSuccedded<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$WalletBalanceAdddedErrorCopyWith<T, $Res> {
  factory _$$WalletBalanceAdddedErrorCopyWith(
          _$WalletBalanceAdddedError<T> value,
          $Res Function(_$WalletBalanceAdddedError<T>) then) =
      __$$WalletBalanceAdddedErrorCopyWithImpl<T, $Res>;
  @useResult
  $Res call({NetworkExceptions networkExceptions});

  $NetworkExceptionsCopyWith<$Res> get networkExceptions;
}

/// @nodoc
class __$$WalletBalanceAdddedErrorCopyWithImpl<T, $Res>
    extends _$MenuStateCopyWithImpl<T, $Res, _$WalletBalanceAdddedError<T>>
    implements _$$WalletBalanceAdddedErrorCopyWith<T, $Res> {
  __$$WalletBalanceAdddedErrorCopyWithImpl(_$WalletBalanceAdddedError<T> _value,
      $Res Function(_$WalletBalanceAdddedError<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? networkExceptions = null,
  }) {
    return _then(_$WalletBalanceAdddedError<T>(
      null == networkExceptions
          ? _value.networkExceptions
          : networkExceptions // ignore: cast_nullable_to_non_nullable
              as NetworkExceptions,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $NetworkExceptionsCopyWith<$Res> get networkExceptions {
    return $NetworkExceptionsCopyWith<$Res>(_value.networkExceptions, (value) {
      return _then(_value.copyWith(networkExceptions: value));
    });
  }
}

/// @nodoc

class _$WalletBalanceAdddedError<T> implements WalletBalanceAdddedError<T> {
  const _$WalletBalanceAdddedError(this.networkExceptions);

  @override
  final NetworkExceptions networkExceptions;

  @override
  String toString() {
    return 'MenuState<$T>.walletBalanceAdddedError(networkExceptions: $networkExceptions)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WalletBalanceAdddedError<T> &&
            (identical(other.networkExceptions, networkExceptions) ||
                other.networkExceptions == networkExceptions));
  }

  @override
  int get hashCode => Object.hash(runtimeType, networkExceptions);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WalletBalanceAdddedErrorCopyWith<T, _$WalletBalanceAdddedError<T>>
      get copyWith => __$$WalletBalanceAdddedErrorCopyWithImpl<T,
          _$WalletBalanceAdddedError<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() walletInfoLoading,
    required TResult Function(WalletInfo data) walletInfoSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletInfoError,
    required TResult Function() userSkillsLoading,
    required TResult Function(List<SkillModel> skills) userSkillsSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        userSkillsError,
    required TResult Function() updateSkillLoading,
    required TResult Function(UpdateSkill data) updateSkillSuccess,
    required TResult Function(NetworkExceptions networkExceptions)
        updateSkillError,
    required TResult Function() walletBlanceAddedLoading,
    required TResult Function(AddBalance data) walletBalanceAddedSuccedded,
    required TResult Function(NetworkExceptions networkExceptions)
        walletBalanceAdddedError,
  }) {
    return walletBalanceAdddedError(networkExceptions);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? walletInfoLoading,
    TResult? Function(WalletInfo data)? walletInfoSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult? Function()? userSkillsLoading,
    TResult? Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult? Function()? updateSkillLoading,
    TResult? Function(UpdateSkill data)? updateSkillSuccess,
    TResult? Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult? Function()? walletBlanceAddedLoading,
    TResult? Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult? Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
  }) {
    return walletBalanceAdddedError?.call(networkExceptions);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? walletInfoLoading,
    TResult Function(WalletInfo data)? walletInfoSuccedded,
    TResult Function(NetworkExceptions networkExceptions)? walletInfoError,
    TResult Function()? userSkillsLoading,
    TResult Function(List<SkillModel> skills)? userSkillsSuccess,
    TResult Function(NetworkExceptions networkExceptions)? userSkillsError,
    TResult Function()? updateSkillLoading,
    TResult Function(UpdateSkill data)? updateSkillSuccess,
    TResult Function(NetworkExceptions networkExceptions)? updateSkillError,
    TResult Function()? walletBlanceAddedLoading,
    TResult Function(AddBalance data)? walletBalanceAddedSuccedded,
    TResult Function(NetworkExceptions networkExceptions)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (walletBalanceAdddedError != null) {
      return walletBalanceAdddedError(networkExceptions);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Idle<T> value) idle,
    required TResult Function(WalletInfoLoading<T> value) walletInfoLoading,
    required TResult Function(WalletInfoSuccedded<T> value) walletInfoSuccedded,
    required TResult Function(WalletInfoError<T> value) walletInfoError,
    required TResult Function(UserSkillsLoading<T> value) userSkillsLoading,
    required TResult Function(UserSkillsSuccess<T> value) userSkillsSuccess,
    required TResult Function(UserSkillsError<T> value) userSkillsError,
    required TResult Function(UpdateSkillLoading<T> value) updateSkillLoading,
    required TResult Function(UpdateSkillSuccess<T> value) updateSkillSuccess,
    required TResult Function(UpdateSkillError<T> value) updateSkillError,
    required TResult Function(WalletBlanceAddedLoading<T> value)
        walletBlanceAddedLoading,
    required TResult Function(WalletBalanceAddedSuccedded<T> value)
        walletBalanceAddedSuccedded,
    required TResult Function(WalletBalanceAdddedError<T> value)
        walletBalanceAdddedError,
  }) {
    return walletBalanceAdddedError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Idle<T> value)? idle,
    TResult? Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult? Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult? Function(WalletInfoError<T> value)? walletInfoError,
    TResult? Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult? Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult? Function(UserSkillsError<T> value)? userSkillsError,
    TResult? Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult? Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult? Function(UpdateSkillError<T> value)? updateSkillError,
    TResult? Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult? Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult? Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
  }) {
    return walletBalanceAdddedError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Idle<T> value)? idle,
    TResult Function(WalletInfoLoading<T> value)? walletInfoLoading,
    TResult Function(WalletInfoSuccedded<T> value)? walletInfoSuccedded,
    TResult Function(WalletInfoError<T> value)? walletInfoError,
    TResult Function(UserSkillsLoading<T> value)? userSkillsLoading,
    TResult Function(UserSkillsSuccess<T> value)? userSkillsSuccess,
    TResult Function(UserSkillsError<T> value)? userSkillsError,
    TResult Function(UpdateSkillLoading<T> value)? updateSkillLoading,
    TResult Function(UpdateSkillSuccess<T> value)? updateSkillSuccess,
    TResult Function(UpdateSkillError<T> value)? updateSkillError,
    TResult Function(WalletBlanceAddedLoading<T> value)?
        walletBlanceAddedLoading,
    TResult Function(WalletBalanceAddedSuccedded<T> value)?
        walletBalanceAddedSuccedded,
    TResult Function(WalletBalanceAdddedError<T> value)?
        walletBalanceAdddedError,
    required TResult orElse(),
  }) {
    if (walletBalanceAdddedError != null) {
      return walletBalanceAdddedError(this);
    }
    return orElse();
  }
}

abstract class WalletBalanceAdddedError<T> implements MenuState<T> {
  const factory WalletBalanceAdddedError(
          final NetworkExceptions networkExceptions) =
      _$WalletBalanceAdddedError<T>;

  NetworkExceptions get networkExceptions;
  @JsonKey(ignore: true)
  _$$WalletBalanceAdddedErrorCopyWith<T, _$WalletBalanceAdddedError<T>>
      get copyWith => throw _privateConstructorUsedError;
}
